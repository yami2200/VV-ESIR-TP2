digraph G {
testSubtract;
select;
testCollate;
testSize_Iterator;
testHashCodeNullEquator;
testUnionNullColl2;
testIsEqualCollectionNullColl2;
testUnionNullColl1;
testIsEqualCollectionNullColl1;
testIsSubCollectionNullColl2;
testIsSubCollectionNullColl1;
countMatches;
testRemoveRangeStartIndexNegative;
testSubtractWithPredicate;
testTransformingCollectionNullTransformer;
testSynchronizedCollection;
setUp;
testIsEmptyWithNull;
filterInverseNullParameters;
testSubtractNullColl2;
testSubtractNullColl1;
testSize_Array;
predicatedCollection;
testSizeIsEmpty_PrimitiveArray;
extractSingleton;
getFromHashMap;
testIsEqualCollectionEquator;
getFromLinkedHashMap;
testSizeIsEmpty_List;
testSize_Other;
testSize_PrimitiveArray;
testIsEqualCollection2;
getFromMapIndexOutOfRange;
emptyCollection;
addAllForIterable;
testIsEqualCollectionToSelf;
testIsEqualCollectionNullEquator;
testContainsAnyNullColl1;
testContainsAnyNullColl3;
testRemoveRangeEndIndexNegative;
testContainsAnyNullColl2;
filterNullParameters;
transform2;
forAllButLastDoIterator;
testDisjunctionNullColl1;
testRemoveCountWithNull;
transform1;
addAllForElements;
testDisjunctionNullColl2;
getFromIterator;
getFromEnumeration;
testSizeIsEmpty_Other;
testIntersectionNullColl2;
addIgnoreNull;
getFromIterable;
testMatchesAll;
testRemoveAll;
testRemoveRange;
testSizeIsEmpty_Enumeration;
get;
testIntersectionNullColl1;
testSizeIsEmpty_Map;
testAddIgnoreNullNullColl;
testRemoveCount;
testRetainAllNullBaseColl;
testIsProperSubCollection;
collateException1;
collateException2;
containsAll;
testAddAllNullColl5;
forAllDoIterator;
getNegative;
collateException0;
forAllDoCollection;
union;
reverse;
testTransformedCollection_2;
emptyIfNull;
testCollateIgnoreDuplicates;
testIsFullNullColl;
filter;
testIsEmptyWithEmptyCollection;
getFromObject;
testIsEqualCollection;
testSize_Enumeration;
getFromList;
testAddAllNullColl4;
exists;
testAddAllNullColl3;
testAddAllNullColl2;
testRemoveAllNullSubColl;
isFull;
testPredicatedCollectionNullColl;
testIsNotEmptyWithNull;
forAllButLastDoCollection;
forAllDoFailure;
testRemoveCountStartNegative;
containsAnyInArray;
getFromPrimitiveArray;
selectWithOutputCollections;
testPredicatedCollectionNullPredicate;
testRemoveCountNegative;
testRemoveRangeNull;
testRetainAllWithEquator;
testaddAllNullColl1;
testPermutations;
testRemoveAllNullBaseColl;
testDisjunctionAsSymmetricDifference;
containsAnyInCollection;
find;
getFromTreeMap;
intersection;
testRemoveRangeEndLowStart;
testIsSubCollection2;
testIsSubCollection;
getEnumeration;
testIsEqualCollectionReturnsFalse;
testContainsAnyInArrayNullColl1;
testSize_Map;
getPositiveOutOfBounds;
testContainsAnyInArrayNullColl2;
get1;
testIsSubCollectionOfSelf;
testHashCode;
cardinalityOfNull;
testIsEmptyWithNonEmptyCollection;
getIterator;
testSizeIsEmpty_Null;
testTransformingCollectionNullColl;
testRetainAllNullSubColl;
filterInverse;
getFromObjectArray;
collect;
testSize_List;
testPermutationsWithNullCollection;
testSizeIsEmpty_Array;
testUnmodifiableCollection;
testRemoveAllWithEquator;
testRemoveCountWrongCount;
maxSize;
testHashCodeNullCollection;
testSizeIsEmpty_Iterator;
getCardinalityMap;
testIsNotEmptyWithNonEmptyCollection;
testRemoveRangeWrongEndIndex;
testGetCardinalityMapNull;
testContainsAnyInArrayNullArray;
intersectionUsesMethodEquals;
testIsNotEmptyWithEmptyCollection;
testRetainAll;
disjunction;
testTransformedCollection;
selectRejected;
testReverseArrayNull;
isEmpty;
testIsProperSubCollectionNullColl2;
testIsProperSubCollectionNullColl1;
cardinality;
addAllForEnumeration;
testMaxSizeNullColl;
testDisjunctionAsUnionMinusIntersection;
testSubtract -> forAllButLastDoCollection [label=" collectionA", dir=none];
testSubtract -> getFromPrimitiveArray [label=" iterableA, collectionA, iterableB", dir=none];
testSubtract -> testCollate [label=" collectionA", dir=none];
testSubtract -> selectWithOutputCollections [label=" collectionA", dir=none];
testSubtract -> testUnionNullColl2 [label=" iterableA, collectionA, collectionC2, iterableB, iterableC", dir=none];
testSubtract -> testPermutations [label=" collectionA", dir=none];
testSubtract -> testUnionNullColl1 [label=" iterableA, collectionA, collectionC2, iterableB, iterableC", dir=none];
testSubtract -> testDisjunctionAsSymmetricDifference [label=" iterableA, collectionA, collectionC2, iterableB, iterableC", dir=none];
testSubtract -> countMatches [label=" iterableA, iterableB", dir=none];
testSubtract -> testSubtractWithPredicate [label=" iterableA, collectionA, iterableB", dir=none];
testSubtract -> find [label=" collectionA", dir=none];
testSubtract -> getFromTreeMap [label=" iterableA, collectionA, iterableB", dir=none];
testSubtract -> intersection [label=" iterableA, collectionA, collectionC2, iterableB, iterableC", dir=none];
testSubtract -> setUp [label=" iterableA, collectionA, collectionC2, iterableB, iterableC", dir=none];
testSubtract -> testIsEmptyWithNull [label=" collectionA", dir=none];
testSubtract -> testIsSubCollection2 [label=" collectionA", dir=none];
testSubtract -> testIsSubCollection [label=" collectionA", dir=none];
testSubtract -> getEnumeration [label=" iterableA, collectionA, iterableB", dir=none];
testSubtract -> testIsEqualCollectionReturnsFalse [label=" collectionA", dir=none];
testSubtract -> filterInverseNullParameters [label=" iterableA, collectionA, iterableB", dir=none];
testSubtract -> getPositiveOutOfBounds [label=" iterableA, collectionA, iterableB", dir=none];
testSubtract -> get1 [label=" iterableA, collectionA, iterableB", dir=none];
testSubtract -> testIsSubCollectionOfSelf [label=" collectionA", dir=none];
testSubtract -> testHashCode [label=" collectionA", dir=none];
testSubtract -> cardinalityOfNull [label=" iterableA, collectionA, iterableB", dir=none];
testSubtract -> getFromHashMap [label=" iterableA, collectionA, iterableB", dir=none];
testSubtract -> testIsEmptyWithNonEmptyCollection [label=" collectionA", dir=none];
testSubtract -> testIsEqualCollectionEquator [label=" iterableA, collectionA", dir=none];
testSubtract -> getFromLinkedHashMap [label=" iterableA, collectionA, iterableB", dir=none];
testSubtract -> getIterator [label=" iterableA, collectionA, iterableB", dir=none];
testSubtract -> getFromMapIndexOutOfRange [label=" iterableA, collectionA, iterableB", dir=none];
testSubtract -> filterInverse [label=" iterableA, collectionA, iterableB", dir=none];
testSubtract -> getFromObjectArray [label=" iterableA, collectionA, iterableB", dir=none];
testSubtract -> collect [label=" iterableA, collectionA", dir=none];
testSubtract -> testIsEqualCollectionToSelf [label=" collectionA", dir=none];
testSubtract -> testIsEqualCollectionNullEquator [label=" collectionA", dir=none];
testSubtract -> filterNullParameters [label=" iterableA, collectionA, iterableB", dir=none];
testSubtract -> forAllButLastDoIterator [label=" collectionA", dir=none];
testSubtract -> testDisjunctionNullColl1 [label=" iterableA, collectionA, collectionC2, iterableB, iterableC", dir=none];
testSubtract -> transform1 [label=" iterableA, collectionA, iterableB", dir=none];
testSubtract -> addAllForElements [label=" collectionA", dir=none];
testSubtract -> testDisjunctionNullColl2 [label=" iterableA, collectionA, collectionC2, iterableB, iterableC", dir=none];
testSubtract -> getFromIterator [label=" iterableA, collectionA, iterableB", dir=none];
testSubtract -> getFromEnumeration [label=" iterableA, collectionA, iterableB", dir=none];
testSubtract -> testIntersectionNullColl2 [label=" iterableA, collectionA, collectionC2, iterableB, iterableC", dir=none];
testSubtract -> getFromIterable [label=" iterableA, collectionA, iterableB", dir=none];
testSubtract -> getCardinalityMap [label=" iterableA, collectionA, iterableB", dir=none];
testSubtract -> testMatchesAll [label=" collectionA", dir=none];
testSubtract -> testRemoveRange [label=" iterableA, collectionA, iterableB", dir=none];
testSubtract -> get [label=" iterableA, collectionA, iterableB", dir=none];
testSubtract -> testIntersectionNullColl1 [label=" iterableA, collectionA, collectionC2, iterableB, iterableC", dir=none];
testSubtract -> testRemoveCount [label=" iterableA, collectionA, iterableB", dir=none];
testSubtract -> testGetCardinalityMapNull [label=" iterableA, collectionA, iterableB", dir=none];
testSubtract -> intersectionUsesMethodEquals [label=" iterableA, collectionA, collectionC2, iterableB, iterableC", dir=none];
testSubtract -> testIsProperSubCollection [label=" iterableA, collectionA, collectionC2, iterableB, iterableC", dir=none];
testSubtract -> collateException1 [label=" collectionA", dir=none];
testSubtract -> collateException2 [label=" collectionA", dir=none];
testSubtract -> disjunction [label=" iterableA, collectionA, collectionC2, iterableB, iterableC", dir=none];
testSubtract -> isEmpty [label=" collectionA", dir=none];
testSubtract -> forAllDoIterator [label=" collectionA", dir=none];
testSubtract -> getNegative [label=" iterableA, collectionA, iterableB", dir=none];
testSubtract -> forAllDoCollection [label=" collectionA", dir=none];
testSubtract -> union [label=" iterableA, collectionA, collectionC2, iterableB, iterableC", dir=none];
testSubtract -> reverse [label=" collectionA", dir=none];
testSubtract -> cardinality [label=" iterableA, iterableB", dir=none];
testSubtract -> emptyIfNull [label=" collectionA", dir=none];
testSubtract -> filter [label=" iterableA, collectionA, iterableB", dir=none];
testSubtract -> testIsEmptyWithEmptyCollection [label=" collectionA", dir=none];
testSubtract -> getFromObject [label=" iterableA, collectionA, iterableB", dir=none];
testSubtract -> addAllForEnumeration [label=" collectionA", dir=none];
testSubtract -> testIsEqualCollection [label=" collectionA", dir=none];
testSubtract -> getFromList [label=" iterableA, collectionA, iterableB", dir=none];
testSubtract -> testDisjunctionAsUnionMinusIntersection [label=" iterableA, collectionA, collectionC2, iterableB, iterableC", dir=none];
forAllButLastDoCollection -> getFromPrimitiveArray [label=" collectionA", dir=none];
forAllButLastDoCollection -> selectWithOutputCollections [label=" collectionA", dir=none];
forAllButLastDoCollection -> testPermutations [label=" collectionA", dir=none];
forAllButLastDoCollection -> testDisjunctionAsSymmetricDifference [label=" collectionA", dir=none];
forAllButLastDoCollection -> getCardinalityMap [label=" collectionA", dir=none];
forAllButLastDoCollection -> find [label=" collectionA", dir=none];
forAllButLastDoCollection -> getFromTreeMap [label=" collectionA", dir=none];
forAllButLastDoCollection -> intersection [label=" collectionA", dir=none];
forAllButLastDoCollection -> testGetCardinalityMapNull [label=" collectionA", dir=none];
forAllButLastDoCollection -> testIsSubCollection2 [label=" collectionA", dir=none];
forAllButLastDoCollection -> testIsSubCollection [label=" collectionA", dir=none];
forAllButLastDoCollection -> intersectionUsesMethodEquals [label=" collectionA", dir=none];
forAllButLastDoCollection -> getEnumeration [label=" collectionA", dir=none];
forAllButLastDoCollection -> testIsEqualCollectionReturnsFalse [label=" collectionA", dir=none];
forAllButLastDoCollection -> getPositiveOutOfBounds [label=" collectionA", dir=none];
forAllButLastDoCollection -> disjunction [label=" collectionA", dir=none];
forAllButLastDoCollection -> isEmpty [label=" collectionA", dir=none];
forAllButLastDoCollection -> get1 [label=" collectionA", dir=none];
forAllButLastDoCollection -> testIsSubCollectionOfSelf [label=" collectionA, collectionB", dir=none];
forAllButLastDoCollection -> testHashCode [label=" collectionA", dir=none];
forAllButLastDoCollection -> cardinalityOfNull [label=" collectionA", dir=none];
forAllButLastDoCollection -> testIsEmptyWithNonEmptyCollection [label=" collectionA", dir=none];
forAllButLastDoCollection -> getIterator [label=" collectionA", dir=none];
forAllButLastDoCollection -> addAllForEnumeration [label=" collectionA", dir=none];
forAllButLastDoCollection -> filterInverse [label=" collectionA", dir=none];
forAllButLastDoCollection -> getFromObjectArray [label=" collectionA", dir=none];
forAllButLastDoCollection -> collect [label=" collectionA, collectionB", dir=none];
forAllButLastDoCollection -> testDisjunctionAsUnionMinusIntersection [label=" collectionA", dir=none];
select -> countMatches [label=" EQUALS_TWO", dir=none];
select -> filter [label=" EQUALS_TWO", dir=none];
select -> filterInverseNullParameters [label=" EQUALS_TWO", dir=none];
select -> selectWithOutputCollections [label=" EQUALS_TWO", dir=none];
select -> filterNullParameters [label=" EQUALS_TWO", dir=none];
select -> selectRejected [label=" EQUALS_TWO", dir=none];
select -> exists [label=" EQUALS_TWO", dir=none];
select -> filterInverse [label=" EQUALS_TWO", dir=none];
getFromPrimitiveArray -> selectWithOutputCollections [label=" collectionA", dir=none];
getFromPrimitiveArray -> testPermutations [label=" collectionA", dir=none];
getFromPrimitiveArray -> testDisjunctionAsSymmetricDifference [label=" collectionA, iterableA, iterableB", dir=none];
getFromPrimitiveArray -> getCardinalityMap [label=" collectionA, iterableA, iterableB", dir=none];
getFromPrimitiveArray -> find [label=" collectionA", dir=none];
getFromPrimitiveArray -> getFromTreeMap [label=" collectionA, iterableA, iterableB", dir=none];
getFromPrimitiveArray -> intersection [label=" collectionA, iterableA, iterableB", dir=none];
getFromPrimitiveArray -> testGetCardinalityMapNull [label=" collectionA, iterableA, iterableB", dir=none];
getFromPrimitiveArray -> testIsSubCollection2 [label=" collectionA", dir=none];
getFromPrimitiveArray -> testIsSubCollection [label=" collectionA", dir=none];
getFromPrimitiveArray -> intersectionUsesMethodEquals [label=" collectionA, iterableA, iterableB", dir=none];
getFromPrimitiveArray -> getEnumeration [label=" collectionA, iterableA, iterableB", dir=none];
getFromPrimitiveArray -> testIsEqualCollectionReturnsFalse [label=" collectionA", dir=none];
getFromPrimitiveArray -> getPositiveOutOfBounds [label=" collectionA, iterableA, iterableB", dir=none];
getFromPrimitiveArray -> disjunction [label=" collectionA, iterableA, iterableB", dir=none];
getFromPrimitiveArray -> isEmpty [label=" collectionA", dir=none];
getFromPrimitiveArray -> get1 [label=" collectionA, iterableA, iterableB", dir=none];
getFromPrimitiveArray -> testIsSubCollectionOfSelf [label=" collectionA", dir=none];
getFromPrimitiveArray -> testHashCode [label=" collectionA", dir=none];
getFromPrimitiveArray -> cardinalityOfNull [label=" collectionA, iterableA, iterableB", dir=none];
getFromPrimitiveArray -> cardinality [label=" iterableA, iterableB", dir=none];
getFromPrimitiveArray -> testIsEmptyWithNonEmptyCollection [label=" collectionA", dir=none];
getFromPrimitiveArray -> getIterator [label=" collectionA, iterableA, iterableB", dir=none];
getFromPrimitiveArray -> addAllForEnumeration [label=" collectionA", dir=none];
getFromPrimitiveArray -> filterInverse [label=" collectionA, iterableA, iterableB", dir=none];
getFromPrimitiveArray -> getFromObjectArray [label=" collectionA, iterableA, iterableB", dir=none];
getFromPrimitiveArray -> collect [label=" collectionA, iterableA", dir=none];
getFromPrimitiveArray -> testDisjunctionAsUnionMinusIntersection [label=" collectionA, iterableA, iterableB", dir=none];
testCollate -> forAllButLastDoCollection [label=" collectionA", dir=none];
testCollate -> getFromPrimitiveArray [label=" collectionA", dir=none];
testCollate -> selectWithOutputCollections [label=" collectionA", dir=none];
testCollate -> testUnionNullColl2 [label=" collectionA", dir=none];
testCollate -> testPermutations [label=" collectionA", dir=none];
testCollate -> testUnionNullColl1 [label=" collectionA", dir=none];
testCollate -> testDisjunctionAsSymmetricDifference [label=" collectionA", dir=none];
testCollate -> testSubtractWithPredicate [label=" collectionA", dir=none];
testCollate -> find [label=" collectionA", dir=none];
testCollate -> getFromTreeMap [label=" collectionA", dir=none];
testCollate -> intersection [label=" collectionA", dir=none];
testCollate -> setUp [label=" collectionA, collectionD, collectionE", dir=none];
testCollate -> testIsEmptyWithNull [label=" collectionA", dir=none];
testCollate -> testIsSubCollection2 [label=" collectionA", dir=none];
testCollate -> testIsSubCollection [label=" collectionA", dir=none];
testCollate -> getEnumeration [label=" collectionA", dir=none];
testCollate -> testIsEqualCollectionReturnsFalse [label=" collectionA", dir=none];
testCollate -> filterInverseNullParameters [label=" collectionA", dir=none];
testCollate -> getPositiveOutOfBounds [label=" collectionA", dir=none];
testCollate -> get1 [label=" collectionA", dir=none];
testCollate -> testIsSubCollectionOfSelf [label=" collectionA", dir=none];
testCollate -> testHashCode [label=" collectionA", dir=none];
testCollate -> cardinalityOfNull [label=" collectionA", dir=none];
testCollate -> getFromHashMap [label=" collectionA", dir=none];
testCollate -> testIsEmptyWithNonEmptyCollection [label=" collectionA", dir=none];
testCollate -> testIsEqualCollectionEquator [label=" collectionA", dir=none];
testCollate -> getFromLinkedHashMap [label=" collectionA", dir=none];
testCollate -> getIterator [label=" collectionA", dir=none];
testCollate -> getFromMapIndexOutOfRange [label=" collectionA", dir=none];
testCollate -> filterInverse [label=" collectionA", dir=none];
testCollate -> getFromObjectArray [label=" collectionA", dir=none];
testCollate -> collect [label=" collectionA", dir=none];
testCollate -> testIsEqualCollectionToSelf [label=" collectionA", dir=none];
testCollate -> testIsEqualCollectionNullEquator [label=" collectionA", dir=none];
testCollate -> filterNullParameters [label=" collectionA", dir=none];
testCollate -> forAllButLastDoIterator [label=" collectionA", dir=none];
testCollate -> testDisjunctionNullColl1 [label=" collectionA", dir=none];
testCollate -> transform1 [label=" collectionA", dir=none];
testCollate -> addAllForElements [label=" collectionA", dir=none];
testCollate -> testDisjunctionNullColl2 [label=" collectionA", dir=none];
testCollate -> getFromIterator [label=" collectionA", dir=none];
testCollate -> getFromEnumeration [label=" collectionA", dir=none];
testCollate -> testIntersectionNullColl2 [label=" collectionA", dir=none];
testCollate -> getFromIterable [label=" collectionA", dir=none];
testCollate -> getCardinalityMap [label=" collectionA", dir=none];
testCollate -> testMatchesAll [label=" collectionA, emptyCollection", dir=none];
testCollate -> testRemoveRange [label=" collectionA", dir=none];
testCollate -> get [label=" collectionA", dir=none];
testCollate -> testIntersectionNullColl1 [label=" collectionA", dir=none];
testCollate -> testRemoveCount [label=" collectionA", dir=none];
testCollate -> testGetCardinalityMapNull [label=" collectionA", dir=none];
testCollate -> intersectionUsesMethodEquals [label=" collectionA", dir=none];
testCollate -> testIsProperSubCollection [label=" collectionA", dir=none];
testCollate -> collateException1 [label=" collectionA", dir=none];
testCollate -> collateException2 [label=" collectionA", dir=none];
testCollate -> disjunction [label=" collectionA", dir=none];
testCollate -> isEmpty [label=" collectionA", dir=none];
testCollate -> forAllDoIterator [label=" collectionA", dir=none];
testCollate -> getNegative [label=" collectionA", dir=none];
testCollate -> forAllDoCollection [label=" collectionA", dir=none];
testCollate -> union [label=" collectionA", dir=none];
testCollate -> reverse [label=" collectionA", dir=none];
testCollate -> emptyIfNull [label=" collectionA", dir=none];
testCollate -> testCollateIgnoreDuplicates [label=" collectionD, collectionE", dir=none];
testCollate -> filter [label=" collectionA", dir=none];
testCollate -> testIsEmptyWithEmptyCollection [label=" collectionA", dir=none];
testCollate -> getFromObject [label=" collectionA", dir=none];
testCollate -> addAllForEnumeration [label=" collectionA", dir=none];
testCollate -> testIsEqualCollection [label=" collectionA", dir=none];
testCollate -> getFromList [label=" collectionA", dir=none];
testCollate -> testDisjunctionAsUnionMinusIntersection [label=" collectionA", dir=none];
selectWithOutputCollections -> testPermutations [label=" collectionA", dir=none];
selectWithOutputCollections -> testDisjunctionAsSymmetricDifference [label=" collectionA", dir=none];
selectWithOutputCollections -> getCardinalityMap [label=" collectionA", dir=none];
selectWithOutputCollections -> find [label=" collectionA", dir=none];
selectWithOutputCollections -> getFromTreeMap [label=" collectionA", dir=none];
selectWithOutputCollections -> intersection [label=" collectionA", dir=none];
selectWithOutputCollections -> testGetCardinalityMapNull [label=" collectionA", dir=none];
selectWithOutputCollections -> testIsSubCollection2 [label=" collectionA", dir=none];
selectWithOutputCollections -> testIsSubCollection [label=" collectionA", dir=none];
selectWithOutputCollections -> intersectionUsesMethodEquals [label=" collectionA", dir=none];
selectWithOutputCollections -> getEnumeration [label=" collectionA", dir=none];
selectWithOutputCollections -> testIsEqualCollectionReturnsFalse [label=" collectionA", dir=none];
selectWithOutputCollections -> getPositiveOutOfBounds [label=" collectionA", dir=none];
selectWithOutputCollections -> disjunction [label=" collectionA", dir=none];
selectWithOutputCollections -> selectRejected [label=" EQUALS_TWO", dir=none];
selectWithOutputCollections -> isEmpty [label=" collectionA", dir=none];
selectWithOutputCollections -> get1 [label=" collectionA", dir=none];
selectWithOutputCollections -> testIsSubCollectionOfSelf [label=" collectionA", dir=none];
selectWithOutputCollections -> testHashCode [label=" collectionA", dir=none];
selectWithOutputCollections -> cardinalityOfNull [label=" collectionA", dir=none];
selectWithOutputCollections -> testIsEmptyWithNonEmptyCollection [label=" collectionA", dir=none];
selectWithOutputCollections -> getIterator [label=" collectionA", dir=none];
selectWithOutputCollections -> addAllForEnumeration [label=" collectionA", dir=none];
selectWithOutputCollections -> filterInverse [label=" collectionA, EQUALS_TWO", dir=none];
selectWithOutputCollections -> getFromObjectArray [label=" collectionA", dir=none];
selectWithOutputCollections -> collect [label=" collectionA", dir=none];
selectWithOutputCollections -> testDisjunctionAsUnionMinusIntersection [label=" collectionA", dir=none];
testHashCodeNullEquator -> testIsEqualCollectionEquator [label=" collectionB", dir=none];
testHashCodeNullEquator -> forAllButLastDoCollection [label=" collectionB", dir=none];
testHashCodeNullEquator -> setUp [label=" collectionB", dir=none];
testHashCodeNullEquator -> forAllButLastDoIterator [label=" collectionB", dir=none];
testHashCodeNullEquator -> testIsSubCollectionOfSelf [label=" collectionB", dir=none];
testHashCodeNullEquator -> collect [label=" collectionB", dir=none];
testHashCodeNullEquator -> testIsEqualCollectionToSelf [label=" collectionB", dir=none];
testUnionNullColl2 -> forAllButLastDoCollection [label=" collectionA", dir=none];
testUnionNullColl2 -> getFromPrimitiveArray [label=" iterableA, collectionA, iterableB", dir=none];
testUnionNullColl2 -> selectWithOutputCollections [label=" collectionA", dir=none];
testUnionNullColl2 -> testPermutations [label=" collectionA", dir=none];
testUnionNullColl2 -> testUnionNullColl1 [label=" iterableA, collectionA, collectionC2, iterableB, iterableC", dir=none];
testUnionNullColl2 -> testDisjunctionAsSymmetricDifference [label=" iterableA, collectionA, collectionC2, iterableB, iterableC", dir=none];
testUnionNullColl2 -> countMatches [label=" iterableA, iterableB", dir=none];
testUnionNullColl2 -> testSubtractWithPredicate [label=" iterableA, collectionA, iterableB", dir=none];
testUnionNullColl2 -> find [label=" collectionA", dir=none];
testUnionNullColl2 -> getFromTreeMap [label=" iterableA, collectionA, iterableB", dir=none];
testUnionNullColl2 -> intersection [label=" iterableA, collectionA, collectionC2, iterableB, iterableC", dir=none];
testUnionNullColl2 -> setUp [label=" iterableA, collectionA, collectionC2, iterableB, iterableC", dir=none];
testUnionNullColl2 -> testIsEmptyWithNull [label=" collectionA", dir=none];
testUnionNullColl2 -> testIsSubCollection2 [label=" collectionA", dir=none];
testUnionNullColl2 -> testIsSubCollection [label=" collectionA", dir=none];
testUnionNullColl2 -> getEnumeration [label=" iterableA, collectionA, iterableB", dir=none];
testUnionNullColl2 -> testIsEqualCollectionReturnsFalse [label=" collectionA", dir=none];
testUnionNullColl2 -> filterInverseNullParameters [label=" iterableA, collectionA, iterableB", dir=none];
testUnionNullColl2 -> getPositiveOutOfBounds [label=" iterableA, collectionA, iterableB", dir=none];
testUnionNullColl2 -> get1 [label=" iterableA, collectionA, iterableB", dir=none];
testUnionNullColl2 -> testIsSubCollectionOfSelf [label=" collectionA", dir=none];
testUnionNullColl2 -> testHashCode [label=" collectionA", dir=none];
testUnionNullColl2 -> cardinalityOfNull [label=" iterableA, collectionA, iterableB", dir=none];
testUnionNullColl2 -> getFromHashMap [label=" iterableA, collectionA, iterableB", dir=none];
testUnionNullColl2 -> testIsEmptyWithNonEmptyCollection [label=" collectionA", dir=none];
testUnionNullColl2 -> testIsEqualCollectionEquator [label=" iterableA, collectionA", dir=none];
testUnionNullColl2 -> getFromLinkedHashMap [label=" iterableA, collectionA, iterableB", dir=none];
testUnionNullColl2 -> getIterator [label=" iterableA, collectionA, iterableB", dir=none];
testUnionNullColl2 -> getFromMapIndexOutOfRange [label=" iterableA, collectionA, iterableB", dir=none];
testUnionNullColl2 -> filterInverse [label=" iterableA, collectionA, iterableB", dir=none];
testUnionNullColl2 -> getFromObjectArray [label=" iterableA, collectionA, iterableB", dir=none];
testUnionNullColl2 -> collect [label=" iterableA, collectionA", dir=none];
testUnionNullColl2 -> testIsEqualCollectionToSelf [label=" collectionA", dir=none];
testUnionNullColl2 -> testIsEqualCollectionNullEquator [label=" collectionA", dir=none];
testUnionNullColl2 -> filterNullParameters [label=" iterableA, collectionA, iterableB", dir=none];
testUnionNullColl2 -> forAllButLastDoIterator [label=" collectionA", dir=none];
testUnionNullColl2 -> testDisjunctionNullColl1 [label=" iterableA, collectionA, collectionC2, iterableB, iterableC", dir=none];
testUnionNullColl2 -> transform1 [label=" iterableA, collectionA, iterableB", dir=none];
testUnionNullColl2 -> addAllForElements [label=" collectionA", dir=none];
testUnionNullColl2 -> testDisjunctionNullColl2 [label=" iterableA, collectionA, collectionC2, iterableB, iterableC", dir=none];
testUnionNullColl2 -> getFromIterator [label=" iterableA, collectionA, iterableB", dir=none];
testUnionNullColl2 -> getFromEnumeration [label=" iterableA, collectionA, iterableB", dir=none];
testUnionNullColl2 -> testIntersectionNullColl2 [label=" iterableA, collectionA, collectionC2, iterableB, iterableC", dir=none];
testUnionNullColl2 -> getFromIterable [label=" iterableA, collectionA, iterableB", dir=none];
testUnionNullColl2 -> getCardinalityMap [label=" iterableA, collectionA, iterableB", dir=none];
testUnionNullColl2 -> testMatchesAll [label=" collectionA", dir=none];
testUnionNullColl2 -> testRemoveRange [label=" iterableA, collectionA, iterableB", dir=none];
testUnionNullColl2 -> get [label=" iterableA, collectionA, iterableB", dir=none];
testUnionNullColl2 -> testIntersectionNullColl1 [label=" iterableA, collectionA, collectionC2, iterableB, iterableC", dir=none];
testUnionNullColl2 -> testRemoveCount [label=" iterableA, collectionA, iterableB", dir=none];
testUnionNullColl2 -> testGetCardinalityMapNull [label=" iterableA, collectionA, iterableB", dir=none];
testUnionNullColl2 -> intersectionUsesMethodEquals [label=" iterableA, collectionA, collectionC2, iterableB, iterableC", dir=none];
testUnionNullColl2 -> testIsProperSubCollection [label=" iterableA, collectionA, collectionC2, iterableB, iterableC", dir=none];
testUnionNullColl2 -> collateException1 [label=" collectionA", dir=none];
testUnionNullColl2 -> collateException2 [label=" collectionA", dir=none];
testUnionNullColl2 -> disjunction [label=" iterableA, collectionA, collectionC2, iterableB, iterableC", dir=none];
testUnionNullColl2 -> isEmpty [label=" collectionA", dir=none];
testUnionNullColl2 -> forAllDoIterator [label=" collectionA", dir=none];
testUnionNullColl2 -> getNegative [label=" iterableA, collectionA, iterableB", dir=none];
testUnionNullColl2 -> forAllDoCollection [label=" collectionA", dir=none];
testUnionNullColl2 -> union [label=" iterableA, collectionA, collectionC2, iterableB, iterableC", dir=none];
testUnionNullColl2 -> reverse [label=" collectionA", dir=none];
testUnionNullColl2 -> cardinality [label=" iterableA, iterableB", dir=none];
testUnionNullColl2 -> emptyIfNull [label=" collectionA", dir=none];
testUnionNullColl2 -> filter [label=" iterableA, collectionA, iterableB", dir=none];
testUnionNullColl2 -> testIsEmptyWithEmptyCollection [label=" collectionA", dir=none];
testUnionNullColl2 -> getFromObject [label=" iterableA, collectionA, iterableB", dir=none];
testUnionNullColl2 -> addAllForEnumeration [label=" collectionA", dir=none];
testUnionNullColl2 -> testIsEqualCollection [label=" collectionA", dir=none];
testUnionNullColl2 -> getFromList [label=" iterableA, collectionA, iterableB", dir=none];
testUnionNullColl2 -> testDisjunctionAsUnionMinusIntersection [label=" iterableA, collectionA, collectionC2, iterableB, iterableC", dir=none];
testPermutations -> testDisjunctionAsSymmetricDifference [label=" collectionA", dir=none];
testPermutations -> getCardinalityMap [label=" collectionA", dir=none];
testPermutations -> find [label=" collectionA", dir=none];
testPermutations -> getFromTreeMap [label=" collectionA", dir=none];
testPermutations -> intersection [label=" collectionA", dir=none];
testPermutations -> testGetCardinalityMapNull [label=" collectionA", dir=none];
testPermutations -> testIsSubCollection2 [label=" collectionA", dir=none];
testPermutations -> testIsSubCollection [label=" collectionA", dir=none];
testPermutations -> intersectionUsesMethodEquals [label=" collectionA", dir=none];
testPermutations -> getEnumeration [label=" collectionA", dir=none];
testPermutations -> testIsEqualCollectionReturnsFalse [label=" collectionA", dir=none];
testPermutations -> getPositiveOutOfBounds [label=" collectionA", dir=none];
testPermutations -> disjunction [label=" collectionA", dir=none];
testPermutations -> isEmpty [label=" collectionA", dir=none];
testPermutations -> get1 [label=" collectionA", dir=none];
testPermutations -> testIsSubCollectionOfSelf [label=" collectionA", dir=none];
testPermutations -> testHashCode [label=" collectionA", dir=none];
testPermutations -> cardinalityOfNull [label=" collectionA", dir=none];
testPermutations -> testIsEmptyWithNonEmptyCollection [label=" collectionA", dir=none];
testPermutations -> getIterator [label=" collectionA", dir=none];
testPermutations -> addAllForEnumeration [label=" collectionA", dir=none];
testPermutations -> filterInverse [label=" collectionA", dir=none];
testPermutations -> getFromObjectArray [label=" collectionA", dir=none];
testPermutations -> collect [label=" collectionA", dir=none];
testPermutations -> testDisjunctionAsUnionMinusIntersection [label=" collectionA", dir=none];
testUnionNullColl1 -> forAllButLastDoCollection [label=" collectionA", dir=none];
testUnionNullColl1 -> getFromPrimitiveArray [label=" iterableA, collectionA, iterableB", dir=none];
testUnionNullColl1 -> selectWithOutputCollections [label=" collectionA", dir=none];
testUnionNullColl1 -> testPermutations [label=" collectionA", dir=none];
testUnionNullColl1 -> testDisjunctionAsSymmetricDifference [label=" iterableA, collectionA, collectionC2, iterableB, iterableC", dir=none];
testUnionNullColl1 -> countMatches [label=" iterableA, iterableB", dir=none];
testUnionNullColl1 -> testSubtractWithPredicate [label=" iterableA, collectionA, iterableB", dir=none];
testUnionNullColl1 -> find [label=" collectionA", dir=none];
testUnionNullColl1 -> getFromTreeMap [label=" iterableA, collectionA, iterableB", dir=none];
testUnionNullColl1 -> intersection [label=" iterableA, collectionA, collectionC2, iterableB, iterableC", dir=none];
testUnionNullColl1 -> setUp [label=" iterableA, collectionA, collectionC2, iterableB, iterableC", dir=none];
testUnionNullColl1 -> testIsEmptyWithNull [label=" collectionA", dir=none];
testUnionNullColl1 -> testIsSubCollection2 [label=" collectionA", dir=none];
testUnionNullColl1 -> testIsSubCollection [label=" collectionA", dir=none];
testUnionNullColl1 -> getEnumeration [label=" iterableA, collectionA, iterableB", dir=none];
testUnionNullColl1 -> testIsEqualCollectionReturnsFalse [label=" collectionA", dir=none];
testUnionNullColl1 -> filterInverseNullParameters [label=" iterableA, collectionA, iterableB", dir=none];
testUnionNullColl1 -> getPositiveOutOfBounds [label=" iterableA, collectionA, iterableB", dir=none];
testUnionNullColl1 -> get1 [label=" iterableA, collectionA, iterableB", dir=none];
testUnionNullColl1 -> testIsSubCollectionOfSelf [label=" collectionA", dir=none];
testUnionNullColl1 -> testHashCode [label=" collectionA", dir=none];
testUnionNullColl1 -> cardinalityOfNull [label=" iterableA, collectionA, iterableB", dir=none];
testUnionNullColl1 -> getFromHashMap [label=" iterableA, collectionA, iterableB", dir=none];
testUnionNullColl1 -> testIsEmptyWithNonEmptyCollection [label=" collectionA", dir=none];
testUnionNullColl1 -> testIsEqualCollectionEquator [label=" iterableA, collectionA", dir=none];
testUnionNullColl1 -> getFromLinkedHashMap [label=" iterableA, collectionA, iterableB", dir=none];
testUnionNullColl1 -> getIterator [label=" iterableA, collectionA, iterableB", dir=none];
testUnionNullColl1 -> getFromMapIndexOutOfRange [label=" iterableA, collectionA, iterableB", dir=none];
testUnionNullColl1 -> filterInverse [label=" iterableA, collectionA, iterableB", dir=none];
testUnionNullColl1 -> getFromObjectArray [label=" iterableA, collectionA, iterableB", dir=none];
testUnionNullColl1 -> collect [label=" iterableA, collectionA", dir=none];
testUnionNullColl1 -> testIsEqualCollectionToSelf [label=" collectionA", dir=none];
testUnionNullColl1 -> testIsEqualCollectionNullEquator [label=" collectionA", dir=none];
testUnionNullColl1 -> filterNullParameters [label=" iterableA, collectionA, iterableB", dir=none];
testUnionNullColl1 -> forAllButLastDoIterator [label=" collectionA", dir=none];
testUnionNullColl1 -> testDisjunctionNullColl1 [label=" iterableA, collectionA, collectionC2, iterableB, iterableC", dir=none];
testUnionNullColl1 -> transform1 [label=" iterableA, collectionA, iterableB", dir=none];
testUnionNullColl1 -> addAllForElements [label=" collectionA", dir=none];
testUnionNullColl1 -> testDisjunctionNullColl2 [label=" iterableA, collectionA, collectionC2, iterableB, iterableC", dir=none];
testUnionNullColl1 -> getFromIterator [label=" iterableA, collectionA, iterableB", dir=none];
testUnionNullColl1 -> getFromEnumeration [label=" iterableA, collectionA, iterableB", dir=none];
testUnionNullColl1 -> testIntersectionNullColl2 [label=" iterableA, collectionA, collectionC2, iterableB, iterableC", dir=none];
testUnionNullColl1 -> getFromIterable [label=" iterableA, collectionA, iterableB", dir=none];
testUnionNullColl1 -> getCardinalityMap [label=" iterableA, collectionA, iterableB", dir=none];
testUnionNullColl1 -> testMatchesAll [label=" collectionA", dir=none];
testUnionNullColl1 -> testRemoveRange [label=" iterableA, collectionA, iterableB", dir=none];
testUnionNullColl1 -> get [label=" iterableA, collectionA, iterableB", dir=none];
testUnionNullColl1 -> testIntersectionNullColl1 [label=" iterableA, collectionA, collectionC2, iterableB, iterableC", dir=none];
testUnionNullColl1 -> testRemoveCount [label=" iterableA, collectionA, iterableB", dir=none];
testUnionNullColl1 -> testGetCardinalityMapNull [label=" iterableA, collectionA, iterableB", dir=none];
testUnionNullColl1 -> intersectionUsesMethodEquals [label=" iterableA, collectionA, collectionC2, iterableB, iterableC", dir=none];
testUnionNullColl1 -> testIsProperSubCollection [label=" iterableA, collectionA, collectionC2, iterableB, iterableC", dir=none];
testUnionNullColl1 -> collateException1 [label=" collectionA", dir=none];
testUnionNullColl1 -> collateException2 [label=" collectionA", dir=none];
testUnionNullColl1 -> disjunction [label=" iterableA, collectionA, collectionC2, iterableB, iterableC", dir=none];
testUnionNullColl1 -> isEmpty [label=" collectionA", dir=none];
testUnionNullColl1 -> forAllDoIterator [label=" collectionA", dir=none];
testUnionNullColl1 -> getNegative [label=" iterableA, collectionA, iterableB", dir=none];
testUnionNullColl1 -> forAllDoCollection [label=" collectionA", dir=none];
testUnionNullColl1 -> union [label=" iterableA, collectionA, collectionC2, iterableB, iterableC", dir=none];
testUnionNullColl1 -> reverse [label=" collectionA", dir=none];
testUnionNullColl1 -> cardinality [label=" iterableA, iterableB", dir=none];
testUnionNullColl1 -> emptyIfNull [label=" collectionA", dir=none];
testUnionNullColl1 -> filter [label=" iterableA, collectionA, iterableB", dir=none];
testUnionNullColl1 -> testIsEmptyWithEmptyCollection [label=" collectionA", dir=none];
testUnionNullColl1 -> getFromObject [label=" iterableA, collectionA, iterableB", dir=none];
testUnionNullColl1 -> addAllForEnumeration [label=" collectionA", dir=none];
testUnionNullColl1 -> testIsEqualCollection [label=" collectionA", dir=none];
testUnionNullColl1 -> getFromList [label=" iterableA, collectionA, iterableB", dir=none];
testUnionNullColl1 -> testDisjunctionAsUnionMinusIntersection [label=" iterableA, collectionA, collectionC2, iterableB, iterableC", dir=none];
testDisjunctionAsSymmetricDifference -> getCardinalityMap [label=" collectionA, iterableA, iterableB", dir=none];
testDisjunctionAsSymmetricDifference -> find [label=" collectionA", dir=none];
testDisjunctionAsSymmetricDifference -> getFromTreeMap [label=" collectionA, iterableA, iterableB", dir=none];
testDisjunctionAsSymmetricDifference -> intersection [label=" collectionA, iterableA, collectionC2, iterableB, iterableC", dir=none];
testDisjunctionAsSymmetricDifference -> testGetCardinalityMapNull [label=" collectionA, iterableA, iterableB", dir=none];
testDisjunctionAsSymmetricDifference -> testIsSubCollection2 [label=" collectionA", dir=none];
testDisjunctionAsSymmetricDifference -> testIsSubCollection [label=" collectionA, collectionC", dir=none];
testDisjunctionAsSymmetricDifference -> intersectionUsesMethodEquals [label=" collectionA, iterableA, collectionC2, iterableB, iterableC", dir=none];
testDisjunctionAsSymmetricDifference -> getEnumeration [label=" collectionA, iterableA, iterableB", dir=none];
testDisjunctionAsSymmetricDifference -> testIsEqualCollectionReturnsFalse [label=" collectionA", dir=none];
testDisjunctionAsSymmetricDifference -> getPositiveOutOfBounds [label=" collectionA, iterableA, iterableB", dir=none];
testDisjunctionAsSymmetricDifference -> disjunction [label=" collectionA, iterableA, collectionC2, iterableB, iterableC", dir=none];
testDisjunctionAsSymmetricDifference -> isEmpty [label=" collectionA", dir=none];
testDisjunctionAsSymmetricDifference -> get1 [label=" collectionA, iterableA, iterableB", dir=none];
testDisjunctionAsSymmetricDifference -> testIsSubCollectionOfSelf [label=" collectionA", dir=none];
testDisjunctionAsSymmetricDifference -> testHashCode [label=" collectionA", dir=none];
testDisjunctionAsSymmetricDifference -> cardinalityOfNull [label=" collectionA, iterableA, iterableB", dir=none];
testDisjunctionAsSymmetricDifference -> cardinality [label=" iterableA, iterableB", dir=none];
testDisjunctionAsSymmetricDifference -> testIsEmptyWithNonEmptyCollection [label=" collectionA", dir=none];
testDisjunctionAsSymmetricDifference -> getIterator [label=" collectionA, iterableA, iterableB", dir=none];
testDisjunctionAsSymmetricDifference -> addAllForEnumeration [label=" collectionA", dir=none];
testDisjunctionAsSymmetricDifference -> filterInverse [label=" collectionA, iterableA, iterableB", dir=none];
testDisjunctionAsSymmetricDifference -> getFromObjectArray [label=" collectionA, iterableA, iterableB", dir=none];
testDisjunctionAsSymmetricDifference -> collect [label=" collectionA, iterableA", dir=none];
testDisjunctionAsSymmetricDifference -> testDisjunctionAsUnionMinusIntersection [label=" collectionA, iterableA, collectionC, collectionC2, iterableB, iterableC", dir=none];
countMatches -> getFromPrimitiveArray [label=" iterableA, iterableB", dir=none];
countMatches -> selectWithOutputCollections [label=" EQUALS_TWO", dir=none];
countMatches -> filterNullParameters [label=" iterableA, EQUALS_TWO, iterableB", dir=none];
countMatches -> testDisjunctionNullColl1 [label=" iterableA, iterableB", dir=none];
countMatches -> transform1 [label=" iterableA, iterableB", dir=none];
countMatches -> testDisjunctionNullColl2 [label=" iterableA, iterableB", dir=none];
countMatches -> getFromIterator [label=" iterableA, iterableB", dir=none];
countMatches -> testDisjunctionAsSymmetricDifference [label=" iterableA, iterableB", dir=none];
countMatches -> getFromEnumeration [label=" iterableA, iterableB", dir=none];
countMatches -> testIntersectionNullColl2 [label=" iterableA, iterableB", dir=none];
countMatches -> testSubtractWithPredicate [label=" iterableA, iterableB", dir=none];
countMatches -> getFromIterable [label=" iterableA, iterableB", dir=none];
countMatches -> getCardinalityMap [label=" iterableA, iterableB", dir=none];
countMatches -> testRemoveRange [label=" iterableA, iterableB", dir=none];
countMatches -> getFromTreeMap [label=" iterableA, iterableB", dir=none];
countMatches -> get [label=" iterableA, iterableB", dir=none];
countMatches -> testIntersectionNullColl1 [label=" iterableA, iterableB", dir=none];
countMatches -> intersection [label=" iterableA, iterableB", dir=none];
countMatches -> setUp [label=" iterableA, iterableB", dir=none];
countMatches -> testRemoveCount [label=" iterableA, iterableB", dir=none];
countMatches -> testGetCardinalityMapNull [label=" iterableA, iterableB", dir=none];
countMatches -> intersectionUsesMethodEquals [label=" iterableA, iterableB", dir=none];
countMatches -> getEnumeration [label=" iterableA, iterableB", dir=none];
countMatches -> testIsProperSubCollection [label=" iterableA, iterableB", dir=none];
countMatches -> filterInverseNullParameters [label=" iterableA, EQUALS_TWO, iterableB", dir=none];
countMatches -> getPositiveOutOfBounds [label=" iterableA, iterableB", dir=none];
countMatches -> disjunction [label=" iterableA, iterableB", dir=none];
countMatches -> selectRejected [label=" EQUALS_TWO", dir=none];
countMatches -> getNegative [label=" iterableA, iterableB", dir=none];
countMatches -> union [label=" iterableA, iterableB", dir=none];
countMatches -> get1 [label=" iterableA, iterableB", dir=none];
countMatches -> cardinalityOfNull [label=" iterableA, iterableB", dir=none];
countMatches -> cardinality [label=" iterableA, iterableB", dir=none];
countMatches -> getFromHashMap [label=" iterableA, iterableB", dir=none];
countMatches -> testIsEqualCollectionEquator [label=" iterableA", dir=none];
countMatches -> filter [label=" iterableA, EQUALS_TWO, iterableB", dir=none];
countMatches -> getFromLinkedHashMap [label=" iterableA, iterableB", dir=none];
countMatches -> getIterator [label=" iterableA, iterableB", dir=none];
countMatches -> getFromObject [label=" iterableA, iterableB", dir=none];
countMatches -> getFromMapIndexOutOfRange [label=" iterableA, iterableB", dir=none];
countMatches -> getFromList [label=" iterableA, iterableB", dir=none];
countMatches -> exists [label=" EQUALS_TWO", dir=none];
countMatches -> filterInverse [label=" iterableA, EQUALS_TWO, iterableB", dir=none];
countMatches -> getFromObjectArray [label=" iterableA, iterableB", dir=none];
countMatches -> collect [label=" iterableA", dir=none];
countMatches -> testDisjunctionAsUnionMinusIntersection [label=" iterableA, iterableB", dir=none];
testSubtractWithPredicate -> forAllButLastDoCollection [label=" collectionA", dir=none];
testSubtractWithPredicate -> getFromPrimitiveArray [label=" iterableA, collectionA, iterableB", dir=none];
testSubtractWithPredicate -> selectWithOutputCollections [label=" collectionA", dir=none];
testSubtractWithPredicate -> testPermutations [label=" collectionA", dir=none];
testSubtractWithPredicate -> testDisjunctionAsSymmetricDifference [label=" iterableA, collectionA, collectionC, iterableB", dir=none];
testSubtractWithPredicate -> find [label=" collectionA", dir=none];
testSubtractWithPredicate -> getFromTreeMap [label=" iterableA, collectionA, iterableB", dir=none];
testSubtractWithPredicate -> intersection [label=" iterableA, collectionA, iterableB", dir=none];
testSubtractWithPredicate -> setUp [label=" iterableA, collectionA, collectionC, iterableB", dir=none];
testSubtractWithPredicate -> testIsEmptyWithNull [label=" collectionA", dir=none];
testSubtractWithPredicate -> testIsSubCollection2 [label=" collectionA", dir=none];
testSubtractWithPredicate -> testIsSubCollection [label=" collectionA, collectionC", dir=none];
testSubtractWithPredicate -> getEnumeration [label=" iterableA, collectionA, iterableB", dir=none];
testSubtractWithPredicate -> testIsEqualCollectionReturnsFalse [label=" collectionA", dir=none];
testSubtractWithPredicate -> filterInverseNullParameters [label=" iterableA, collectionA, iterableB", dir=none];
testSubtractWithPredicate -> getPositiveOutOfBounds [label=" iterableA, collectionA, iterableB", dir=none];
testSubtractWithPredicate -> get1 [label=" iterableA, collectionA, iterableB", dir=none];
testSubtractWithPredicate -> testIsSubCollectionOfSelf [label=" collectionA", dir=none];
testSubtractWithPredicate -> testHashCode [label=" collectionA", dir=none];
testSubtractWithPredicate -> cardinalityOfNull [label=" iterableA, collectionA, iterableB", dir=none];
testSubtractWithPredicate -> getFromHashMap [label=" iterableA, collectionA, iterableB", dir=none];
testSubtractWithPredicate -> testIsEmptyWithNonEmptyCollection [label=" collectionA", dir=none];
testSubtractWithPredicate -> testIsEqualCollectionEquator [label=" iterableA, collectionA", dir=none];
testSubtractWithPredicate -> getFromLinkedHashMap [label=" iterableA, collectionA, iterableB", dir=none];
testSubtractWithPredicate -> getIterator [label=" iterableA, collectionA, iterableB", dir=none];
testSubtractWithPredicate -> getFromMapIndexOutOfRange [label=" iterableA, collectionA, iterableB", dir=none];
testSubtractWithPredicate -> filterInverse [label=" iterableA, collectionA, iterableB", dir=none];
testSubtractWithPredicate -> getFromObjectArray [label=" iterableA, collectionA, iterableB", dir=none];
testSubtractWithPredicate -> collect [label=" iterableA, collectionA", dir=none];
testSubtractWithPredicate -> testIsEqualCollectionToSelf [label=" collectionA", dir=none];
testSubtractWithPredicate -> testIsEqualCollectionNullEquator [label=" collectionA", dir=none];
testSubtractWithPredicate -> filterNullParameters [label=" iterableA, collectionA, iterableB", dir=none];
testSubtractWithPredicate -> forAllButLastDoIterator [label=" collectionA", dir=none];
testSubtractWithPredicate -> testDisjunctionNullColl1 [label=" iterableA, collectionA, iterableB", dir=none];
testSubtractWithPredicate -> transform1 [label=" iterableA, collectionA, iterableB", dir=none];
testSubtractWithPredicate -> addAllForElements [label=" collectionA", dir=none];
testSubtractWithPredicate -> testDisjunctionNullColl2 [label=" iterableA, collectionA, iterableB", dir=none];
testSubtractWithPredicate -> getFromIterator [label=" iterableA, collectionA, iterableB", dir=none];
testSubtractWithPredicate -> getFromEnumeration [label=" iterableA, collectionA, iterableB", dir=none];
testSubtractWithPredicate -> testIntersectionNullColl2 [label=" iterableA, collectionA, iterableB", dir=none];
testSubtractWithPredicate -> getFromIterable [label=" iterableA, collectionA, iterableB", dir=none];
testSubtractWithPredicate -> getCardinalityMap [label=" iterableA, collectionA, iterableB", dir=none];
testSubtractWithPredicate -> testMatchesAll [label=" collectionA", dir=none];
testSubtractWithPredicate -> testRemoveRange [label=" iterableA, collectionA, iterableB", dir=none];
testSubtractWithPredicate -> get [label=" iterableA, collectionA, iterableB", dir=none];
testSubtractWithPredicate -> testIntersectionNullColl1 [label=" iterableA, collectionA, iterableB", dir=none];
testSubtractWithPredicate -> testRemoveCount [label=" iterableA, collectionA, iterableB", dir=none];
testSubtractWithPredicate -> testGetCardinalityMapNull [label=" iterableA, collectionA, iterableB", dir=none];
testSubtractWithPredicate -> intersectionUsesMethodEquals [label=" iterableA, collectionA, iterableB", dir=none];
testSubtractWithPredicate -> testIsProperSubCollection [label=" iterableA, collectionA, collectionC, iterableB", dir=none];
testSubtractWithPredicate -> collateException1 [label=" collectionA", dir=none];
testSubtractWithPredicate -> collateException2 [label=" collectionA, collectionC", dir=none];
testSubtractWithPredicate -> disjunction [label=" iterableA, collectionA, iterableB", dir=none];
testSubtractWithPredicate -> isEmpty [label=" collectionA", dir=none];
testSubtractWithPredicate -> forAllDoIterator [label=" collectionA, collectionC", dir=none];
testSubtractWithPredicate -> getNegative [label=" iterableA, collectionA, iterableB", dir=none];
testSubtractWithPredicate -> collateException0 [label=" collectionC", dir=none];
testSubtractWithPredicate -> forAllDoCollection [label=" collectionA, collectionC", dir=none];
testSubtractWithPredicate -> union [label=" iterableA, collectionA, iterableB", dir=none];
testSubtractWithPredicate -> reverse [label=" collectionA", dir=none];
testSubtractWithPredicate -> cardinality [label=" iterableA, iterableB", dir=none];
testSubtractWithPredicate -> emptyIfNull [label=" collectionA", dir=none];
testSubtractWithPredicate -> filter [label=" iterableA, collectionA, iterableB", dir=none];
testSubtractWithPredicate -> testIsEmptyWithEmptyCollection [label=" collectionA", dir=none];
testSubtractWithPredicate -> getFromObject [label=" iterableA, collectionA, iterableB", dir=none];
testSubtractWithPredicate -> addAllForEnumeration [label=" collectionA", dir=none];
testSubtractWithPredicate -> testIsEqualCollection [label=" collectionA, collectionC", dir=none];
testSubtractWithPredicate -> getFromList [label=" iterableA, collectionA, iterableB", dir=none];
testSubtractWithPredicate -> testDisjunctionAsUnionMinusIntersection [label=" iterableA, collectionA, collectionC, iterableB", dir=none];
find -> getEnumeration [label=" collectionA", dir=none];
find -> testIsEqualCollectionReturnsFalse [label=" collectionA", dir=none];
find -> getPositiveOutOfBounds [label=" collectionA", dir=none];
find -> disjunction [label=" collectionA", dir=none];
find -> isEmpty [label=" collectionA", dir=none];
find -> get1 [label=" collectionA", dir=none];
find -> testIsSubCollectionOfSelf [label=" collectionA", dir=none];
find -> testHashCode [label=" collectionA", dir=none];
find -> cardinalityOfNull [label=" collectionA", dir=none];
find -> testIsEmptyWithNonEmptyCollection [label=" collectionA", dir=none];
find -> getCardinalityMap [label=" collectionA", dir=none];
find -> getIterator [label=" collectionA", dir=none];
find -> addAllForEnumeration [label=" collectionA", dir=none];
find -> getFromTreeMap [label=" collectionA", dir=none];
find -> intersection [label=" collectionA", dir=none];
find -> filterInverse [label=" collectionA", dir=none];
find -> getFromObjectArray [label=" collectionA", dir=none];
find -> testGetCardinalityMapNull [label=" collectionA", dir=none];
find -> testIsSubCollection2 [label=" collectionA", dir=none];
find -> collect [label=" collectionA", dir=none];
find -> testDisjunctionAsUnionMinusIntersection [label=" collectionA", dir=none];
find -> testIsSubCollection [label=" collectionA", dir=none];
find -> intersectionUsesMethodEquals [label=" collectionA", dir=none];
getFromTreeMap -> getEnumeration [label=" collectionA, iterableA, iterableB", dir=none];
getFromTreeMap -> testIsEqualCollectionReturnsFalse [label=" collectionA", dir=none];
getFromTreeMap -> getPositiveOutOfBounds [label=" collectionA, iterableA, iterableB", dir=none];
getFromTreeMap -> disjunction [label=" collectionA, iterableA, iterableB", dir=none];
getFromTreeMap -> isEmpty [label=" collectionA", dir=none];
getFromTreeMap -> get1 [label=" collectionA, iterableA, iterableB", dir=none];
getFromTreeMap -> testIsSubCollectionOfSelf [label=" collectionA", dir=none];
getFromTreeMap -> testHashCode [label=" collectionA", dir=none];
getFromTreeMap -> cardinalityOfNull [label=" collectionA, iterableA, iterableB", dir=none];
getFromTreeMap -> cardinality [label=" iterableA, iterableB", dir=none];
getFromTreeMap -> testIsEmptyWithNonEmptyCollection [label=" collectionA", dir=none];
getFromTreeMap -> getCardinalityMap [label=" collectionA, iterableA, iterableB", dir=none];
getFromTreeMap -> getIterator [label=" collectionA, iterableA, iterableB", dir=none];
getFromTreeMap -> addAllForEnumeration [label=" collectionA", dir=none];
getFromTreeMap -> intersection [label=" collectionA, iterableA, iterableB", dir=none];
getFromTreeMap -> filterInverse [label=" collectionA, iterableA, iterableB", dir=none];
getFromTreeMap -> getFromObjectArray [label=" collectionA, iterableA, iterableB", dir=none];
getFromTreeMap -> testGetCardinalityMapNull [label=" collectionA, iterableA, iterableB", dir=none];
getFromTreeMap -> testIsSubCollection2 [label=" collectionA", dir=none];
getFromTreeMap -> collect [label=" collectionA, iterableA", dir=none];
getFromTreeMap -> testDisjunctionAsUnionMinusIntersection [label=" collectionA, iterableA, iterableB", dir=none];
getFromTreeMap -> testIsSubCollection [label=" collectionA", dir=none];
getFromTreeMap -> intersectionUsesMethodEquals [label=" collectionA, iterableA, iterableB", dir=none];
intersection -> getEnumeration [label=" iterableA, collectionA, iterableB", dir=none];
intersection -> testIsEqualCollectionReturnsFalse [label=" collectionA", dir=none];
intersection -> getPositiveOutOfBounds [label=" iterableA, collectionA, iterableB", dir=none];
intersection -> disjunction [label=" iterableA, collectionA, collectionC2, iterableB, iterableC", dir=none];
intersection -> isEmpty [label=" collectionA", dir=none];
intersection -> get1 [label=" iterableA, collectionA, iterableB", dir=none];
intersection -> testIsSubCollectionOfSelf [label=" collectionA", dir=none];
intersection -> testHashCode [label=" collectionA", dir=none];
intersection -> cardinalityOfNull [label=" iterableA, collectionA, iterableB", dir=none];
intersection -> cardinality [label=" iterableA, iterableB", dir=none];
intersection -> testIsEmptyWithNonEmptyCollection [label=" collectionA", dir=none];
intersection -> getCardinalityMap [label=" iterableA, collectionA, iterableB", dir=none];
intersection -> getIterator [label=" iterableA, collectionA, iterableB", dir=none];
intersection -> addAllForEnumeration [label=" collectionA", dir=none];
intersection -> filterInverse [label=" iterableA, collectionA, iterableB", dir=none];
intersection -> getFromObjectArray [label=" iterableA, collectionA, iterableB", dir=none];
intersection -> testGetCardinalityMapNull [label=" iterableA, collectionA, iterableB", dir=none];
intersection -> testIsSubCollection2 [label=" collectionA", dir=none];
intersection -> collect [label=" iterableA, collectionA", dir=none];
intersection -> testDisjunctionAsUnionMinusIntersection [label=" iterableA, collectionA, collectionC2, iterableB, iterableC", dir=none];
intersection -> testIsSubCollection [label=" collectionA", dir=none];
intersection -> intersectionUsesMethodEquals [label=" iterableA, collectionA, collectionC2, iterableB, iterableC", dir=none];
setUp -> forAllButLastDoCollection [label=" collectionA, collectionB", dir=none];
setUp -> getFromPrimitiveArray [label=" collectionA, iterableB, iterableA", dir=none];
setUp -> selectWithOutputCollections [label=" collectionA", dir=none];
setUp -> testPermutations [label=" collectionA", dir=none];
setUp -> testDisjunctionAsSymmetricDifference [label=" collectionA, collectionC, collectionC2, iterableB, iterableC, iterableA", dir=none];
setUp -> find [label=" collectionA", dir=none];
setUp -> getFromTreeMap [label=" collectionA, iterableB, iterableA", dir=none];
setUp -> intersection [label=" collectionA, collectionC2, iterableB, iterableC, iterableA", dir=none];
setUp -> testIsEmptyWithNull [label=" collectionA", dir=none];
setUp -> testIsSubCollection2 [label=" collectionA", dir=none];
setUp -> testIsSubCollection [label=" collectionA, collectionC", dir=none];
setUp -> getEnumeration [label=" collectionA, iterableB, iterableA", dir=none];
setUp -> testIsEqualCollectionReturnsFalse [label=" collectionA", dir=none];
setUp -> filterInverseNullParameters [label=" collectionA, iterableB, iterableA", dir=none];
setUp -> getPositiveOutOfBounds [label=" collectionA, iterableB, iterableA", dir=none];
setUp -> get1 [label=" collectionA, iterableB, iterableA", dir=none];
setUp -> testIsSubCollectionOfSelf [label=" collectionA, collectionB", dir=none];
setUp -> testHashCode [label=" collectionA", dir=none];
setUp -> cardinalityOfNull [label=" collectionA, iterableB, iterableA, iterableB2, iterableA2", dir=none];
setUp -> getFromHashMap [label=" collectionA, iterableB, iterableA", dir=none];
setUp -> testIsEmptyWithNonEmptyCollection [label=" collectionA", dir=none];
setUp -> testIsEqualCollectionEquator [label=" collectionA, collectionB, iterableA", dir=none];
setUp -> getFromLinkedHashMap [label=" collectionA, iterableB, iterableA", dir=none];
setUp -> getIterator [label=" collectionA, iterableB, iterableA", dir=none];
setUp -> getFromMapIndexOutOfRange [label=" collectionA, iterableB, iterableA", dir=none];
setUp -> filterInverse [label=" collectionA, iterableB, iterableA", dir=none];
setUp -> getFromObjectArray [label=" collectionA, iterableB, iterableA", dir=none];
setUp -> collect [label=" collectionA, collectionB, iterableA", dir=none];
setUp -> testIsEqualCollectionToSelf [label=" collectionA, collectionB", dir=none];
setUp -> testIsEqualCollectionNullEquator [label=" collectionA", dir=none];
setUp -> filterNullParameters [label=" collectionA, iterableB, iterableA", dir=none];
setUp -> forAllButLastDoIterator [label=" collectionA, collectionB", dir=none];
setUp -> testDisjunctionNullColl1 [label=" collectionA, collectionC2, iterableB, iterableC, iterableA", dir=none];
setUp -> transform1 [label=" collectionA, iterableB, iterableA", dir=none];
setUp -> addAllForElements [label=" collectionA", dir=none];
setUp -> testDisjunctionNullColl2 [label=" collectionA, collectionC2, iterableB, iterableC, iterableA", dir=none];
setUp -> getFromIterator [label=" collectionA, iterableB, iterableA", dir=none];
setUp -> getFromEnumeration [label=" collectionA, iterableB, iterableA", dir=none];
setUp -> testIntersectionNullColl2 [label=" collectionA, collectionC2, iterableB, iterableC, iterableA", dir=none];
setUp -> getFromIterable [label=" collectionA, iterableB, iterableA", dir=none];
setUp -> getCardinalityMap [label=" collectionA, iterableB, iterableA", dir=none];
setUp -> testMatchesAll [label=" collectionA", dir=none];
setUp -> testRemoveRange [label=" collectionA, iterableB, iterableA", dir=none];
setUp -> get [label=" collectionA, iterableB, iterableA", dir=none];
setUp -> testIntersectionNullColl1 [label=" collectionA, collectionC2, iterableB, iterableC, iterableA", dir=none];
setUp -> testRemoveCount [label=" collectionA, iterableB, iterableA", dir=none];
setUp -> testGetCardinalityMapNull [label=" collectionA, iterableB, iterableA", dir=none];
setUp -> intersectionUsesMethodEquals [label=" collectionA, collectionC2, iterableB, iterableC, iterableA", dir=none];
setUp -> testIsProperSubCollection [label=" collectionA, collectionC, collectionC2, iterableB, iterableC, iterableA", dir=none];
setUp -> collateException1 [label=" collectionA", dir=none];
setUp -> collateException2 [label=" collectionA, collectionC", dir=none];
setUp -> disjunction [label=" collectionA, collectionC2, iterableB, iterableC, iterableA", dir=none];
setUp -> isEmpty [label=" collectionA", dir=none];
setUp -> forAllDoIterator [label=" collectionA, collectionC", dir=none];
setUp -> getNegative [label=" collectionA, iterableB, iterableA", dir=none];
setUp -> collateException0 [label=" collectionC", dir=none];
setUp -> forAllDoCollection [label=" collectionA, collectionC", dir=none];
setUp -> union [label=" collectionA, collectionC2, iterableB, iterableC, iterableA", dir=none];
setUp -> reverse [label=" collectionA", dir=none];
setUp -> cardinality [label=" iterableB, iterableA, iterableB2, iterableA2", dir=none];
setUp -> emptyIfNull [label=" collectionA", dir=none];
setUp -> testCollateIgnoreDuplicates [label=" collectionD, collectionE", dir=none];
setUp -> filter [label=" collectionA, iterableB, iterableA", dir=none];
setUp -> testIsEmptyWithEmptyCollection [label=" collectionA", dir=none];
setUp -> getFromObject [label=" collectionA, iterableB, iterableA", dir=none];
setUp -> addAllForEnumeration [label=" collectionA", dir=none];
setUp -> testIsEqualCollection [label=" collectionA, collectionC", dir=none];
setUp -> getFromList [label=" collectionA, iterableB, iterableA", dir=none];
setUp -> testDisjunctionAsUnionMinusIntersection [label=" collectionA, collectionC, collectionC2, iterableB, iterableC, iterableA", dir=none];
testIsEmptyWithNull -> forAllButLastDoCollection [label=" collectionA", dir=none];
testIsEmptyWithNull -> getFromPrimitiveArray [label=" collectionA", dir=none];
testIsEmptyWithNull -> selectWithOutputCollections [label=" collectionA", dir=none];
testIsEmptyWithNull -> testPermutations [label=" collectionA", dir=none];
testIsEmptyWithNull -> testDisjunctionAsSymmetricDifference [label=" collectionA", dir=none];
testIsEmptyWithNull -> find [label=" collectionA", dir=none];
testIsEmptyWithNull -> getFromTreeMap [label=" collectionA", dir=none];
testIsEmptyWithNull -> intersection [label=" collectionA", dir=none];
testIsEmptyWithNull -> testIsSubCollection2 [label=" collectionA", dir=none];
testIsEmptyWithNull -> testIsSubCollection [label=" collectionA", dir=none];
testIsEmptyWithNull -> getEnumeration [label=" collectionA", dir=none];
testIsEmptyWithNull -> testIsEqualCollectionReturnsFalse [label=" collectionA", dir=none];
testIsEmptyWithNull -> filterInverseNullParameters [label=" collectionA", dir=none];
testIsEmptyWithNull -> getPositiveOutOfBounds [label=" collectionA", dir=none];
testIsEmptyWithNull -> get1 [label=" collectionA", dir=none];
testIsEmptyWithNull -> testIsSubCollectionOfSelf [label=" collectionA", dir=none];
testIsEmptyWithNull -> testHashCode [label=" collectionA", dir=none];
testIsEmptyWithNull -> cardinalityOfNull [label=" collectionA", dir=none];
testIsEmptyWithNull -> getFromHashMap [label=" collectionA", dir=none];
testIsEmptyWithNull -> testIsEmptyWithNonEmptyCollection [label=" collectionA", dir=none];
testIsEmptyWithNull -> testIsEqualCollectionEquator [label=" collectionA", dir=none];
testIsEmptyWithNull -> getFromLinkedHashMap [label=" collectionA", dir=none];
testIsEmptyWithNull -> getIterator [label=" collectionA", dir=none];
testIsEmptyWithNull -> getFromMapIndexOutOfRange [label=" collectionA", dir=none];
testIsEmptyWithNull -> filterInverse [label=" collectionA", dir=none];
testIsEmptyWithNull -> getFromObjectArray [label=" collectionA", dir=none];
testIsEmptyWithNull -> collect [label=" collectionA", dir=none];
testIsEmptyWithNull -> testIsEqualCollectionToSelf [label=" collectionA", dir=none];
testIsEmptyWithNull -> testIsEqualCollectionNullEquator [label=" collectionA", dir=none];
testIsEmptyWithNull -> filterNullParameters [label=" collectionA", dir=none];
testIsEmptyWithNull -> forAllButLastDoIterator [label=" collectionA", dir=none];
testIsEmptyWithNull -> testDisjunctionNullColl1 [label=" collectionA", dir=none];
testIsEmptyWithNull -> transform1 [label=" collectionA", dir=none];
testIsEmptyWithNull -> addAllForElements [label=" collectionA", dir=none];
testIsEmptyWithNull -> testDisjunctionNullColl2 [label=" collectionA", dir=none];
testIsEmptyWithNull -> getFromIterator [label=" collectionA", dir=none];
testIsEmptyWithNull -> getFromEnumeration [label=" collectionA", dir=none];
testIsEmptyWithNull -> testIntersectionNullColl2 [label=" collectionA", dir=none];
testIsEmptyWithNull -> getFromIterable [label=" collectionA", dir=none];
testIsEmptyWithNull -> getCardinalityMap [label=" collectionA", dir=none];
testIsEmptyWithNull -> testMatchesAll [label=" collectionA", dir=none];
testIsEmptyWithNull -> testRemoveRange [label=" collectionA", dir=none];
testIsEmptyWithNull -> get [label=" collectionA", dir=none];
testIsEmptyWithNull -> testIntersectionNullColl1 [label=" collectionA", dir=none];
testIsEmptyWithNull -> testRemoveCount [label=" collectionA", dir=none];
testIsEmptyWithNull -> testGetCardinalityMapNull [label=" collectionA", dir=none];
testIsEmptyWithNull -> intersectionUsesMethodEquals [label=" collectionA", dir=none];
testIsEmptyWithNull -> testIsProperSubCollection [label=" collectionA", dir=none];
testIsEmptyWithNull -> collateException1 [label=" collectionA", dir=none];
testIsEmptyWithNull -> collateException2 [label=" collectionA", dir=none];
testIsEmptyWithNull -> disjunction [label=" collectionA", dir=none];
testIsEmptyWithNull -> isEmpty [label=" collectionA", dir=none];
testIsEmptyWithNull -> forAllDoIterator [label=" collectionA", dir=none];
testIsEmptyWithNull -> getNegative [label=" collectionA", dir=none];
testIsEmptyWithNull -> forAllDoCollection [label=" collectionA", dir=none];
testIsEmptyWithNull -> union [label=" collectionA", dir=none];
testIsEmptyWithNull -> reverse [label=" collectionA", dir=none];
testIsEmptyWithNull -> emptyIfNull [label=" collectionA", dir=none];
testIsEmptyWithNull -> filter [label=" collectionA", dir=none];
testIsEmptyWithNull -> testIsEmptyWithEmptyCollection [label=" collectionA", dir=none];
testIsEmptyWithNull -> getFromObject [label=" collectionA", dir=none];
testIsEmptyWithNull -> addAllForEnumeration [label=" collectionA", dir=none];
testIsEmptyWithNull -> testIsEqualCollection [label=" collectionA", dir=none];
testIsEmptyWithNull -> getFromList [label=" collectionA", dir=none];
testIsEmptyWithNull -> testDisjunctionAsUnionMinusIntersection [label=" collectionA", dir=none];
testIsSubCollection2 -> getEnumeration [label=" collectionA", dir=none];
testIsSubCollection2 -> testIsEqualCollectionReturnsFalse [label=" collectionA", dir=none];
testIsSubCollection2 -> getPositiveOutOfBounds [label=" collectionA", dir=none];
testIsSubCollection2 -> disjunction [label=" collectionA", dir=none];
testIsSubCollection2 -> isEmpty [label=" collectionA", dir=none];
testIsSubCollection2 -> get1 [label=" collectionA", dir=none];
testIsSubCollection2 -> testIsSubCollectionOfSelf [label=" collectionA", dir=none];
testIsSubCollection2 -> testHashCode [label=" collectionA", dir=none];
testIsSubCollection2 -> cardinalityOfNull [label=" collectionA", dir=none];
testIsSubCollection2 -> testIsEmptyWithNonEmptyCollection [label=" collectionA", dir=none];
testIsSubCollection2 -> getCardinalityMap [label=" collectionA", dir=none];
testIsSubCollection2 -> getIterator [label=" collectionA", dir=none];
testIsSubCollection2 -> addAllForEnumeration [label=" collectionA", dir=none];
testIsSubCollection2 -> filterInverse [label=" collectionA", dir=none];
testIsSubCollection2 -> getFromObjectArray [label=" collectionA", dir=none];
testIsSubCollection2 -> testGetCardinalityMapNull [label=" collectionA", dir=none];
testIsSubCollection2 -> collect [label=" collectionA", dir=none];
testIsSubCollection2 -> testDisjunctionAsUnionMinusIntersection [label=" collectionA", dir=none];
testIsSubCollection2 -> testIsSubCollection [label=" collectionA", dir=none];
testIsSubCollection2 -> intersectionUsesMethodEquals [label=" collectionA", dir=none];
testIsSubCollection -> getEnumeration [label=" collectionA", dir=none];
testIsSubCollection -> testIsEqualCollectionReturnsFalse [label=" collectionA", dir=none];
testIsSubCollection -> getPositiveOutOfBounds [label=" collectionA", dir=none];
testIsSubCollection -> disjunction [label=" collectionA", dir=none];
testIsSubCollection -> isEmpty [label=" collectionA", dir=none];
testIsSubCollection -> get1 [label=" collectionA", dir=none];
testIsSubCollection -> testIsSubCollectionOfSelf [label=" collectionA", dir=none];
testIsSubCollection -> testHashCode [label=" collectionA", dir=none];
testIsSubCollection -> cardinalityOfNull [label=" collectionA", dir=none];
testIsSubCollection -> testIsEmptyWithNonEmptyCollection [label=" collectionA", dir=none];
testIsSubCollection -> getCardinalityMap [label=" collectionA", dir=none];
testIsSubCollection -> getIterator [label=" collectionA", dir=none];
testIsSubCollection -> addAllForEnumeration [label=" collectionA", dir=none];
testIsSubCollection -> filterInverse [label=" collectionA", dir=none];
testIsSubCollection -> getFromObjectArray [label=" collectionA", dir=none];
testIsSubCollection -> testGetCardinalityMapNull [label=" collectionA", dir=none];
testIsSubCollection -> collect [label=" collectionA", dir=none];
testIsSubCollection -> testDisjunctionAsUnionMinusIntersection [label=" collectionA, collectionC", dir=none];
testIsSubCollection -> intersectionUsesMethodEquals [label=" collectionA", dir=none];
getEnumeration -> testIsEqualCollectionReturnsFalse [label=" collectionA", dir=none];
getEnumeration -> getPositiveOutOfBounds [label=" collectionA, iterableA, iterableB", dir=none];
getEnumeration -> disjunction [label=" collectionA, iterableA, iterableB", dir=none];
getEnumeration -> isEmpty [label=" collectionA", dir=none];
getEnumeration -> get1 [label=" collectionA, iterableA, iterableB", dir=none];
getEnumeration -> testIsSubCollectionOfSelf [label=" collectionA", dir=none];
getEnumeration -> testHashCode [label=" collectionA", dir=none];
getEnumeration -> cardinalityOfNull [label=" collectionA, iterableA, iterableB", dir=none];
getEnumeration -> cardinality [label=" iterableA, iterableB", dir=none];
getEnumeration -> testIsEmptyWithNonEmptyCollection [label=" collectionA", dir=none];
getEnumeration -> getCardinalityMap [label=" collectionA, iterableA, iterableB", dir=none];
getEnumeration -> getIterator [label=" collectionA, iterableA, iterableB", dir=none];
getEnumeration -> addAllForEnumeration [label=" collectionA", dir=none];
getEnumeration -> filterInverse [label=" collectionA, iterableA, iterableB", dir=none];
getEnumeration -> getFromObjectArray [label=" collectionA, iterableA, iterableB", dir=none];
getEnumeration -> testGetCardinalityMapNull [label=" collectionA, iterableA, iterableB", dir=none];
getEnumeration -> collect [label=" collectionA, iterableA", dir=none];
getEnumeration -> testDisjunctionAsUnionMinusIntersection [label=" collectionA, iterableA, iterableB", dir=none];
getEnumeration -> intersectionUsesMethodEquals [label=" collectionA, iterableA, iterableB", dir=none];
testIsEqualCollectionReturnsFalse -> getPositiveOutOfBounds [label=" collectionA", dir=none];
testIsEqualCollectionReturnsFalse -> disjunction [label=" collectionA", dir=none];
testIsEqualCollectionReturnsFalse -> isEmpty [label=" collectionA", dir=none];
testIsEqualCollectionReturnsFalse -> get1 [label=" collectionA", dir=none];
testIsEqualCollectionReturnsFalse -> testIsSubCollectionOfSelf [label=" collectionA", dir=none];
testIsEqualCollectionReturnsFalse -> testHashCode [label=" collectionA", dir=none];
testIsEqualCollectionReturnsFalse -> cardinalityOfNull [label=" collectionA", dir=none];
testIsEqualCollectionReturnsFalse -> testIsEmptyWithNonEmptyCollection [label=" collectionA", dir=none];
testIsEqualCollectionReturnsFalse -> getCardinalityMap [label=" collectionA", dir=none];
testIsEqualCollectionReturnsFalse -> getIterator [label=" collectionA", dir=none];
testIsEqualCollectionReturnsFalse -> addAllForEnumeration [label=" collectionA", dir=none];
testIsEqualCollectionReturnsFalse -> filterInverse [label=" collectionA", dir=none];
testIsEqualCollectionReturnsFalse -> getFromObjectArray [label=" collectionA", dir=none];
testIsEqualCollectionReturnsFalse -> testGetCardinalityMapNull [label=" collectionA", dir=none];
testIsEqualCollectionReturnsFalse -> collect [label=" collectionA", dir=none];
testIsEqualCollectionReturnsFalse -> testDisjunctionAsUnionMinusIntersection [label=" collectionA", dir=none];
testIsEqualCollectionReturnsFalse -> intersectionUsesMethodEquals [label=" collectionA", dir=none];
filterInverseNullParameters -> forAllButLastDoCollection [label=" collectionA", dir=none];
filterInverseNullParameters -> getFromPrimitiveArray [label=" collectionA, iterableA, iterableB", dir=none];
filterInverseNullParameters -> selectWithOutputCollections [label=" collectionA, EQUALS_TWO", dir=none];
filterInverseNullParameters -> testPermutations [label=" collectionA", dir=none];
filterInverseNullParameters -> testDisjunctionAsSymmetricDifference [label=" collectionA, iterableA, iterableB", dir=none];
filterInverseNullParameters -> find [label=" collectionA", dir=none];
filterInverseNullParameters -> getFromTreeMap [label=" collectionA, iterableA, iterableB", dir=none];
filterInverseNullParameters -> intersection [label=" collectionA, iterableA, iterableB", dir=none];
filterInverseNullParameters -> testIsSubCollection2 [label=" collectionA", dir=none];
filterInverseNullParameters -> testIsSubCollection [label=" collectionA", dir=none];
filterInverseNullParameters -> getEnumeration [label=" collectionA, iterableA, iterableB", dir=none];
filterInverseNullParameters -> testIsEqualCollectionReturnsFalse [label=" collectionA", dir=none];
filterInverseNullParameters -> getPositiveOutOfBounds [label=" collectionA, iterableA, iterableB", dir=none];
filterInverseNullParameters -> get1 [label=" collectionA, iterableA, iterableB", dir=none];
filterInverseNullParameters -> testIsSubCollectionOfSelf [label=" collectionA", dir=none];
filterInverseNullParameters -> testHashCode [label=" collectionA", dir=none];
filterInverseNullParameters -> cardinalityOfNull [label=" collectionA, iterableA, iterableB", dir=none];
filterInverseNullParameters -> getFromHashMap [label=" collectionA, iterableA, iterableB", dir=none];
filterInverseNullParameters -> testIsEmptyWithNonEmptyCollection [label=" collectionA", dir=none];
filterInverseNullParameters -> testIsEqualCollectionEquator [label=" collectionA, iterableA", dir=none];
filterInverseNullParameters -> getFromLinkedHashMap [label=" collectionA, iterableA, iterableB", dir=none];
filterInverseNullParameters -> getIterator [label=" collectionA, iterableA, iterableB", dir=none];
filterInverseNullParameters -> getFromMapIndexOutOfRange [label=" collectionA, iterableA, iterableB", dir=none];
filterInverseNullParameters -> filterInverse [label=" collectionA, iterableA, EQUALS_TWO, iterableB", dir=none];
filterInverseNullParameters -> getFromObjectArray [label=" collectionA, iterableA, iterableB", dir=none];
filterInverseNullParameters -> collect [label=" collectionA, iterableA", dir=none];
filterInverseNullParameters -> testIsEqualCollectionToSelf [label=" collectionA", dir=none];
filterInverseNullParameters -> testIsEqualCollectionNullEquator [label=" collectionA", dir=none];
filterInverseNullParameters -> filterNullParameters [label=" collectionA, iterableA, EQUALS_TWO, iterableB", dir=none];
filterInverseNullParameters -> forAllButLastDoIterator [label=" collectionA", dir=none];
filterInverseNullParameters -> testDisjunctionNullColl1 [label=" collectionA, iterableA, iterableB", dir=none];
filterInverseNullParameters -> transform1 [label=" collectionA, iterableA, iterableB", dir=none];
filterInverseNullParameters -> addAllForElements [label=" collectionA", dir=none];
filterInverseNullParameters -> testDisjunctionNullColl2 [label=" collectionA, iterableA, iterableB", dir=none];
filterInverseNullParameters -> getFromIterator [label=" collectionA, iterableA, iterableB", dir=none];
filterInverseNullParameters -> getFromEnumeration [label=" collectionA, iterableA, iterableB", dir=none];
filterInverseNullParameters -> testIntersectionNullColl2 [label=" collectionA, iterableA, iterableB", dir=none];
filterInverseNullParameters -> getFromIterable [label=" collectionA, iterableA, iterableB", dir=none];
filterInverseNullParameters -> getCardinalityMap [label=" collectionA, iterableA, iterableB", dir=none];
filterInverseNullParameters -> testMatchesAll [label=" collectionA", dir=none];
filterInverseNullParameters -> testRemoveRange [label=" collectionA, iterableA, iterableB", dir=none];
filterInverseNullParameters -> get [label=" collectionA, iterableA, iterableB", dir=none];
filterInverseNullParameters -> testIntersectionNullColl1 [label=" collectionA, iterableA, iterableB", dir=none];
filterInverseNullParameters -> testRemoveCount [label=" collectionA, iterableA, iterableB", dir=none];
filterInverseNullParameters -> testGetCardinalityMapNull [label=" collectionA, iterableA, iterableB", dir=none];
filterInverseNullParameters -> intersectionUsesMethodEquals [label=" collectionA, iterableA, iterableB", dir=none];
filterInverseNullParameters -> testIsProperSubCollection [label=" collectionA, iterableA, iterableB", dir=none];
filterInverseNullParameters -> collateException1 [label=" collectionA", dir=none];
filterInverseNullParameters -> collateException2 [label=" collectionA", dir=none];
filterInverseNullParameters -> disjunction [label=" collectionA, iterableA, iterableB", dir=none];
filterInverseNullParameters -> selectRejected [label=" EQUALS_TWO", dir=none];
filterInverseNullParameters -> isEmpty [label=" collectionA", dir=none];
filterInverseNullParameters -> forAllDoIterator [label=" collectionA", dir=none];
filterInverseNullParameters -> getNegative [label=" collectionA, iterableA, iterableB", dir=none];
filterInverseNullParameters -> forAllDoCollection [label=" collectionA", dir=none];
filterInverseNullParameters -> union [label=" collectionA, iterableA, iterableB", dir=none];
filterInverseNullParameters -> reverse [label=" collectionA", dir=none];
filterInverseNullParameters -> cardinality [label=" iterableA, iterableB", dir=none];
filterInverseNullParameters -> emptyIfNull [label=" collectionA", dir=none];
filterInverseNullParameters -> filter [label=" collectionA, iterableA, EQUALS_TWO, iterableB", dir=none];
filterInverseNullParameters -> testIsEmptyWithEmptyCollection [label=" collectionA", dir=none];
filterInverseNullParameters -> getFromObject [label=" collectionA, iterableA, iterableB", dir=none];
filterInverseNullParameters -> addAllForEnumeration [label=" collectionA", dir=none];
filterInverseNullParameters -> testIsEqualCollection [label=" collectionA", dir=none];
filterInverseNullParameters -> getFromList [label=" collectionA, iterableA, iterableB", dir=none];
filterInverseNullParameters -> exists [label=" EQUALS_TWO", dir=none];
filterInverseNullParameters -> testDisjunctionAsUnionMinusIntersection [label=" collectionA, iterableA, iterableB", dir=none];
getPositiveOutOfBounds -> disjunction [label=" collectionA, iterableA, iterableB", dir=none];
getPositiveOutOfBounds -> isEmpty [label=" collectionA", dir=none];
getPositiveOutOfBounds -> get1 [label=" collectionA, iterableA, iterableB", dir=none];
getPositiveOutOfBounds -> testIsSubCollectionOfSelf [label=" collectionA", dir=none];
getPositiveOutOfBounds -> testHashCode [label=" collectionA", dir=none];
getPositiveOutOfBounds -> cardinalityOfNull [label=" collectionA, iterableA, iterableB", dir=none];
getPositiveOutOfBounds -> cardinality [label=" iterableA, iterableB", dir=none];
getPositiveOutOfBounds -> testIsEmptyWithNonEmptyCollection [label=" collectionA", dir=none];
getPositiveOutOfBounds -> getCardinalityMap [label=" collectionA, iterableA, iterableB", dir=none];
getPositiveOutOfBounds -> getIterator [label=" collectionA, iterableA, iterableB", dir=none];
getPositiveOutOfBounds -> addAllForEnumeration [label=" collectionA", dir=none];
getPositiveOutOfBounds -> filterInverse [label=" collectionA, iterableA, iterableB", dir=none];
getPositiveOutOfBounds -> getFromObjectArray [label=" collectionA, iterableA, iterableB", dir=none];
getPositiveOutOfBounds -> testGetCardinalityMapNull [label=" collectionA, iterableA, iterableB", dir=none];
getPositiveOutOfBounds -> collect [label=" collectionA, iterableA", dir=none];
getPositiveOutOfBounds -> testDisjunctionAsUnionMinusIntersection [label=" collectionA, iterableA, iterableB", dir=none];
getPositiveOutOfBounds -> intersectionUsesMethodEquals [label=" collectionA, iterableA, iterableB", dir=none];
get1 -> disjunction [label=" collectionA, iterableA, iterableB", dir=none];
get1 -> isEmpty [label=" collectionA", dir=none];
get1 -> testIsSubCollectionOfSelf [label=" collectionA", dir=none];
get1 -> testHashCode [label=" collectionA", dir=none];
get1 -> cardinalityOfNull [label=" collectionA, iterableA, iterableB", dir=none];
get1 -> cardinality [label=" iterableA, iterableB", dir=none];
get1 -> testIsEmptyWithNonEmptyCollection [label=" collectionA", dir=none];
get1 -> getCardinalityMap [label=" collectionA, iterableA, iterableB", dir=none];
get1 -> getIterator [label=" collectionA, iterableA, iterableB", dir=none];
get1 -> addAllForEnumeration [label=" collectionA", dir=none];
get1 -> filterInverse [label=" collectionA, iterableA, iterableB", dir=none];
get1 -> getFromObjectArray [label=" collectionA, iterableA, iterableB", dir=none];
get1 -> testGetCardinalityMapNull [label=" collectionA, iterableA, iterableB", dir=none];
get1 -> collect [label=" collectionA, iterableA", dir=none];
get1 -> testDisjunctionAsUnionMinusIntersection [label=" collectionA, iterableA, iterableB", dir=none];
get1 -> intersectionUsesMethodEquals [label=" collectionA, iterableA, iterableB", dir=none];
testIsSubCollectionOfSelf -> disjunction [label=" collectionA", dir=none];
testIsSubCollectionOfSelf -> isEmpty [label=" collectionA", dir=none];
testIsSubCollectionOfSelf -> testHashCode [label=" collectionA", dir=none];
testIsSubCollectionOfSelf -> cardinalityOfNull [label=" collectionA", dir=none];
testIsSubCollectionOfSelf -> testIsEmptyWithNonEmptyCollection [label=" collectionA", dir=none];
testIsSubCollectionOfSelf -> getCardinalityMap [label=" collectionA", dir=none];
testIsSubCollectionOfSelf -> getIterator [label=" collectionA", dir=none];
testIsSubCollectionOfSelf -> addAllForEnumeration [label=" collectionA", dir=none];
testIsSubCollectionOfSelf -> filterInverse [label=" collectionA", dir=none];
testIsSubCollectionOfSelf -> getFromObjectArray [label=" collectionA", dir=none];
testIsSubCollectionOfSelf -> testGetCardinalityMapNull [label=" collectionA", dir=none];
testIsSubCollectionOfSelf -> collect [label=" collectionA, collectionB", dir=none];
testIsSubCollectionOfSelf -> testDisjunctionAsUnionMinusIntersection [label=" collectionA", dir=none];
testIsSubCollectionOfSelf -> intersectionUsesMethodEquals [label=" collectionA", dir=none];
testHashCode -> disjunction [label=" collectionA", dir=none];
testHashCode -> isEmpty [label=" collectionA", dir=none];
testHashCode -> cardinalityOfNull [label=" collectionA", dir=none];
testHashCode -> testIsEmptyWithNonEmptyCollection [label=" collectionA", dir=none];
testHashCode -> getCardinalityMap [label=" collectionA", dir=none];
testHashCode -> getIterator [label=" collectionA", dir=none];
testHashCode -> addAllForEnumeration [label=" collectionA", dir=none];
testHashCode -> filterInverse [label=" collectionA", dir=none];
testHashCode -> getFromObjectArray [label=" collectionA", dir=none];
testHashCode -> testGetCardinalityMapNull [label=" collectionA", dir=none];
testHashCode -> collect [label=" collectionA", dir=none];
testHashCode -> testDisjunctionAsUnionMinusIntersection [label=" collectionA", dir=none];
testHashCode -> intersectionUsesMethodEquals [label=" collectionA", dir=none];
cardinalityOfNull -> disjunction [label=" iterableA, collectionA, iterableB", dir=none];
cardinalityOfNull -> isEmpty [label=" collectionA", dir=none];
cardinalityOfNull -> cardinality [label=" iterableA, iterableB, iterableB2, iterableA2", dir=none];
cardinalityOfNull -> testIsEmptyWithNonEmptyCollection [label=" collectionA", dir=none];
cardinalityOfNull -> getCardinalityMap [label=" iterableA, collectionA, iterableB", dir=none];
cardinalityOfNull -> getIterator [label=" iterableA, collectionA, iterableB", dir=none];
cardinalityOfNull -> addAllForEnumeration [label=" collectionA", dir=none];
cardinalityOfNull -> filterInverse [label=" iterableA, collectionA, iterableB", dir=none];
cardinalityOfNull -> getFromObjectArray [label=" iterableA, collectionA, iterableB", dir=none];
cardinalityOfNull -> testGetCardinalityMapNull [label=" iterableA, collectionA, iterableB", dir=none];
cardinalityOfNull -> collect [label=" iterableA, collectionA", dir=none];
cardinalityOfNull -> testDisjunctionAsUnionMinusIntersection [label=" iterableA, collectionA, iterableB", dir=none];
cardinalityOfNull -> intersectionUsesMethodEquals [label=" iterableA, collectionA, iterableB", dir=none];
getFromHashMap -> forAllButLastDoCollection [label=" collectionA", dir=none];
getFromHashMap -> getFromPrimitiveArray [label=" collectionA, iterableA, iterableB", dir=none];
getFromHashMap -> selectWithOutputCollections [label=" collectionA", dir=none];
getFromHashMap -> testPermutations [label=" collectionA", dir=none];
getFromHashMap -> testDisjunctionAsSymmetricDifference [label=" collectionA, iterableA, iterableB", dir=none];
getFromHashMap -> find [label=" collectionA", dir=none];
getFromHashMap -> getFromTreeMap [label=" collectionA, iterableA, iterableB", dir=none];
getFromHashMap -> intersection [label=" collectionA, iterableA, iterableB", dir=none];
getFromHashMap -> testIsSubCollection2 [label=" collectionA", dir=none];
getFromHashMap -> testIsSubCollection [label=" collectionA", dir=none];
getFromHashMap -> getEnumeration [label=" collectionA, iterableA, iterableB", dir=none];
getFromHashMap -> testIsEqualCollectionReturnsFalse [label=" collectionA", dir=none];
getFromHashMap -> getPositiveOutOfBounds [label=" collectionA, iterableA, iterableB", dir=none];
getFromHashMap -> get1 [label=" collectionA, iterableA, iterableB", dir=none];
getFromHashMap -> testIsSubCollectionOfSelf [label=" collectionA", dir=none];
getFromHashMap -> testHashCode [label=" collectionA", dir=none];
getFromHashMap -> cardinalityOfNull [label=" collectionA, iterableA, iterableB", dir=none];
getFromHashMap -> testIsEmptyWithNonEmptyCollection [label=" collectionA", dir=none];
getFromHashMap -> testIsEqualCollectionEquator [label=" collectionA, iterableA", dir=none];
getFromHashMap -> getFromLinkedHashMap [label=" collectionA, iterableA, iterableB", dir=none];
getFromHashMap -> getIterator [label=" collectionA, iterableA, iterableB", dir=none];
getFromHashMap -> getFromMapIndexOutOfRange [label=" collectionA, iterableA, iterableB", dir=none];
getFromHashMap -> filterInverse [label=" collectionA, iterableA, iterableB", dir=none];
getFromHashMap -> getFromObjectArray [label=" collectionA, iterableA, iterableB", dir=none];
getFromHashMap -> collect [label=" collectionA, iterableA", dir=none];
getFromHashMap -> testIsEqualCollectionToSelf [label=" collectionA", dir=none];
getFromHashMap -> testIsEqualCollectionNullEquator [label=" collectionA", dir=none];
getFromHashMap -> filterNullParameters [label=" collectionA, iterableA, iterableB", dir=none];
getFromHashMap -> forAllButLastDoIterator [label=" collectionA", dir=none];
getFromHashMap -> testDisjunctionNullColl1 [label=" collectionA, iterableA, iterableB", dir=none];
getFromHashMap -> transform1 [label=" collectionA, iterableA, iterableB", dir=none];
getFromHashMap -> addAllForElements [label=" collectionA", dir=none];
getFromHashMap -> testDisjunctionNullColl2 [label=" collectionA, iterableA, iterableB", dir=none];
getFromHashMap -> getFromIterator [label=" collectionA, iterableA, iterableB", dir=none];
getFromHashMap -> getFromEnumeration [label=" collectionA, iterableA, iterableB", dir=none];
getFromHashMap -> testIntersectionNullColl2 [label=" collectionA, iterableA, iterableB", dir=none];
getFromHashMap -> getFromIterable [label=" collectionA, iterableA, iterableB", dir=none];
getFromHashMap -> getCardinalityMap [label=" collectionA, iterableA, iterableB", dir=none];
getFromHashMap -> testMatchesAll [label=" collectionA", dir=none];
getFromHashMap -> testRemoveRange [label=" collectionA, iterableA, iterableB", dir=none];
getFromHashMap -> get [label=" collectionA, iterableA, iterableB", dir=none];
getFromHashMap -> testIntersectionNullColl1 [label=" collectionA, iterableA, iterableB", dir=none];
getFromHashMap -> testRemoveCount [label=" collectionA, iterableA, iterableB", dir=none];
getFromHashMap -> testGetCardinalityMapNull [label=" collectionA, iterableA, iterableB", dir=none];
getFromHashMap -> intersectionUsesMethodEquals [label=" collectionA, iterableA, iterableB", dir=none];
getFromHashMap -> testIsProperSubCollection [label=" collectionA, iterableA, iterableB", dir=none];
getFromHashMap -> collateException1 [label=" collectionA", dir=none];
getFromHashMap -> collateException2 [label=" collectionA", dir=none];
getFromHashMap -> disjunction [label=" collectionA, iterableA, iterableB", dir=none];
getFromHashMap -> isEmpty [label=" collectionA", dir=none];
getFromHashMap -> forAllDoIterator [label=" collectionA", dir=none];
getFromHashMap -> getNegative [label=" collectionA, iterableA, iterableB", dir=none];
getFromHashMap -> forAllDoCollection [label=" collectionA", dir=none];
getFromHashMap -> union [label=" collectionA, iterableA, iterableB", dir=none];
getFromHashMap -> reverse [label=" collectionA", dir=none];
getFromHashMap -> cardinality [label=" iterableA, iterableB", dir=none];
getFromHashMap -> emptyIfNull [label=" collectionA", dir=none];
getFromHashMap -> filter [label=" collectionA, iterableA, iterableB", dir=none];
getFromHashMap -> testIsEmptyWithEmptyCollection [label=" collectionA", dir=none];
getFromHashMap -> getFromObject [label=" collectionA, iterableA, iterableB", dir=none];
getFromHashMap -> addAllForEnumeration [label=" collectionA", dir=none];
getFromHashMap -> testIsEqualCollection [label=" collectionA", dir=none];
getFromHashMap -> getFromList [label=" collectionA, iterableA, iterableB", dir=none];
getFromHashMap -> testDisjunctionAsUnionMinusIntersection [label=" collectionA, iterableA, iterableB", dir=none];
testIsEmptyWithNonEmptyCollection -> getCardinalityMap [label=" collectionA", dir=none];
testIsEmptyWithNonEmptyCollection -> getIterator [label=" collectionA", dir=none];
testIsEmptyWithNonEmptyCollection -> addAllForEnumeration [label=" collectionA", dir=none];
testIsEmptyWithNonEmptyCollection -> disjunction [label=" collectionA", dir=none];
testIsEmptyWithNonEmptyCollection -> isEmpty [label=" collectionA", dir=none];
testIsEmptyWithNonEmptyCollection -> filterInverse [label=" collectionA", dir=none];
testIsEmptyWithNonEmptyCollection -> getFromObjectArray [label=" collectionA", dir=none];
testIsEmptyWithNonEmptyCollection -> testGetCardinalityMapNull [label=" collectionA", dir=none];
testIsEmptyWithNonEmptyCollection -> collect [label=" collectionA", dir=none];
testIsEmptyWithNonEmptyCollection -> testDisjunctionAsUnionMinusIntersection [label=" collectionA", dir=none];
testIsEmptyWithNonEmptyCollection -> intersectionUsesMethodEquals [label=" collectionA", dir=none];
testIsEqualCollectionEquator -> forAllButLastDoCollection [label=" collectionA, collectionB", dir=none];
testIsEqualCollectionEquator -> getFromPrimitiveArray [label=" collectionA, iterableA", dir=none];
testIsEqualCollectionEquator -> selectWithOutputCollections [label=" collectionA", dir=none];
testIsEqualCollectionEquator -> testPermutations [label=" collectionA", dir=none];
testIsEqualCollectionEquator -> testDisjunctionAsSymmetricDifference [label=" collectionA, iterableA", dir=none];
testIsEqualCollectionEquator -> find [label=" collectionA", dir=none];
testIsEqualCollectionEquator -> getFromTreeMap [label=" collectionA, iterableA", dir=none];
testIsEqualCollectionEquator -> intersection [label=" collectionA, iterableA", dir=none];
testIsEqualCollectionEquator -> testIsSubCollection2 [label=" collectionA", dir=none];
testIsEqualCollectionEquator -> testIsSubCollection [label=" collectionA", dir=none];
testIsEqualCollectionEquator -> getEnumeration [label=" collectionA, iterableA", dir=none];
testIsEqualCollectionEquator -> testIsEqualCollectionReturnsFalse [label=" collectionA", dir=none];
testIsEqualCollectionEquator -> getPositiveOutOfBounds [label=" collectionA, iterableA", dir=none];
testIsEqualCollectionEquator -> get1 [label=" collectionA, iterableA", dir=none];
testIsEqualCollectionEquator -> testIsSubCollectionOfSelf [label=" collectionA, collectionB", dir=none];
testIsEqualCollectionEquator -> testHashCode [label=" collectionA", dir=none];
testIsEqualCollectionEquator -> cardinalityOfNull [label=" collectionA, iterableA", dir=none];
testIsEqualCollectionEquator -> testIsEmptyWithNonEmptyCollection [label=" collectionA", dir=none];
testIsEqualCollectionEquator -> getFromLinkedHashMap [label=" collectionA, iterableA", dir=none];
testIsEqualCollectionEquator -> getIterator [label=" collectionA, iterableA", dir=none];
testIsEqualCollectionEquator -> getFromMapIndexOutOfRange [label=" collectionA, iterableA", dir=none];
testIsEqualCollectionEquator -> filterInverse [label=" collectionA, iterableA", dir=none];
testIsEqualCollectionEquator -> getFromObjectArray [label=" collectionA, iterableA", dir=none];
testIsEqualCollectionEquator -> collect [label=" collectionA, iterableA, collectionB", dir=none];
testIsEqualCollectionEquator -> testIsEqualCollectionToSelf [label=" collectionA, collectionB", dir=none];
testIsEqualCollectionEquator -> testIsEqualCollectionNullEquator [label=" collectionA", dir=none];
testIsEqualCollectionEquator -> filterNullParameters [label=" collectionA, iterableA", dir=none];
testIsEqualCollectionEquator -> forAllButLastDoIterator [label=" collectionA, collectionB", dir=none];
testIsEqualCollectionEquator -> testDisjunctionNullColl1 [label=" collectionA, iterableA", dir=none];
testIsEqualCollectionEquator -> transform1 [label=" collectionA, iterableA, TRANSFORM_TO_INTEGER", dir=none];
testIsEqualCollectionEquator -> addAllForElements [label=" collectionA", dir=none];
testIsEqualCollectionEquator -> testDisjunctionNullColl2 [label=" collectionA, iterableA", dir=none];
testIsEqualCollectionEquator -> getFromIterator [label=" collectionA, iterableA", dir=none];
testIsEqualCollectionEquator -> getFromEnumeration [label=" collectionA, iterableA", dir=none];
testIsEqualCollectionEquator -> testIntersectionNullColl2 [label=" collectionA, iterableA", dir=none];
testIsEqualCollectionEquator -> getFromIterable [label=" collectionA, iterableA", dir=none];
testIsEqualCollectionEquator -> getCardinalityMap [label=" collectionA, iterableA", dir=none];
testIsEqualCollectionEquator -> testMatchesAll [label=" collectionA", dir=none];
testIsEqualCollectionEquator -> testRemoveRange [label=" collectionA, iterableA", dir=none];
testIsEqualCollectionEquator -> get [label=" collectionA, iterableA", dir=none];
testIsEqualCollectionEquator -> testIntersectionNullColl1 [label=" collectionA, iterableA", dir=none];
testIsEqualCollectionEquator -> testRemoveCount [label=" collectionA, iterableA", dir=none];
testIsEqualCollectionEquator -> testGetCardinalityMapNull [label=" collectionA, iterableA", dir=none];
testIsEqualCollectionEquator -> intersectionUsesMethodEquals [label=" collectionA, iterableA", dir=none];
testIsEqualCollectionEquator -> testIsProperSubCollection [label=" collectionA, iterableA", dir=none];
testIsEqualCollectionEquator -> collateException1 [label=" collectionA", dir=none];
testIsEqualCollectionEquator -> collateException2 [label=" collectionA", dir=none];
testIsEqualCollectionEquator -> disjunction [label=" collectionA, iterableA", dir=none];
testIsEqualCollectionEquator -> isEmpty [label=" collectionA", dir=none];
testIsEqualCollectionEquator -> forAllDoIterator [label=" collectionA", dir=none];
testIsEqualCollectionEquator -> getNegative [label=" collectionA, iterableA", dir=none];
testIsEqualCollectionEquator -> forAllDoCollection [label=" collectionA", dir=none];
testIsEqualCollectionEquator -> union [label=" collectionA, iterableA", dir=none];
testIsEqualCollectionEquator -> reverse [label=" collectionA", dir=none];
testIsEqualCollectionEquator -> testTransformedCollection_2 [label=" TRANSFORM_TO_INTEGER", dir=none];
testIsEqualCollectionEquator -> cardinality [label=" iterableA", dir=none];
testIsEqualCollectionEquator -> emptyIfNull [label=" collectionA", dir=none];
testIsEqualCollectionEquator -> filter [label=" collectionA, iterableA", dir=none];
testIsEqualCollectionEquator -> testIsEmptyWithEmptyCollection [label=" collectionA", dir=none];
testIsEqualCollectionEquator -> getFromObject [label=" collectionA, iterableA", dir=none];
testIsEqualCollectionEquator -> addAllForEnumeration [label=" collectionA", dir=none];
testIsEqualCollectionEquator -> testIsEqualCollection [label=" collectionA", dir=none];
testIsEqualCollectionEquator -> getFromList [label=" collectionA, iterableA", dir=none];
testIsEqualCollectionEquator -> testDisjunctionAsUnionMinusIntersection [label=" collectionA, iterableA", dir=none];
getFromLinkedHashMap -> forAllButLastDoCollection [label=" collectionA", dir=none];
getFromLinkedHashMap -> getFromPrimitiveArray [label=" collectionA, iterableA, iterableB", dir=none];
getFromLinkedHashMap -> selectWithOutputCollections [label=" collectionA", dir=none];
getFromLinkedHashMap -> testPermutations [label=" collectionA", dir=none];
getFromLinkedHashMap -> testDisjunctionAsSymmetricDifference [label=" collectionA, iterableA, iterableB", dir=none];
getFromLinkedHashMap -> find [label=" collectionA", dir=none];
getFromLinkedHashMap -> getFromTreeMap [label=" collectionA, iterableA, iterableB", dir=none];
getFromLinkedHashMap -> intersection [label=" collectionA, iterableA, iterableB", dir=none];
getFromLinkedHashMap -> testIsSubCollection2 [label=" collectionA", dir=none];
getFromLinkedHashMap -> testIsSubCollection [label=" collectionA", dir=none];
getFromLinkedHashMap -> getEnumeration [label=" collectionA, iterableA, iterableB", dir=none];
getFromLinkedHashMap -> testIsEqualCollectionReturnsFalse [label=" collectionA", dir=none];
getFromLinkedHashMap -> getPositiveOutOfBounds [label=" collectionA, iterableA, iterableB", dir=none];
getFromLinkedHashMap -> get1 [label=" collectionA, iterableA, iterableB", dir=none];
getFromLinkedHashMap -> testIsSubCollectionOfSelf [label=" collectionA", dir=none];
getFromLinkedHashMap -> testHashCode [label=" collectionA", dir=none];
getFromLinkedHashMap -> cardinalityOfNull [label=" collectionA, iterableA, iterableB", dir=none];
getFromLinkedHashMap -> testIsEmptyWithNonEmptyCollection [label=" collectionA", dir=none];
getFromLinkedHashMap -> getIterator [label=" collectionA, iterableA, iterableB", dir=none];
getFromLinkedHashMap -> getFromMapIndexOutOfRange [label=" collectionA, iterableA, iterableB", dir=none];
getFromLinkedHashMap -> filterInverse [label=" collectionA, iterableA, iterableB", dir=none];
getFromLinkedHashMap -> getFromObjectArray [label=" collectionA, iterableA, iterableB", dir=none];
getFromLinkedHashMap -> collect [label=" collectionA, iterableA", dir=none];
getFromLinkedHashMap -> testIsEqualCollectionToSelf [label=" collectionA", dir=none];
getFromLinkedHashMap -> testIsEqualCollectionNullEquator [label=" collectionA", dir=none];
getFromLinkedHashMap -> filterNullParameters [label=" collectionA, iterableA, iterableB", dir=none];
getFromLinkedHashMap -> forAllButLastDoIterator [label=" collectionA", dir=none];
getFromLinkedHashMap -> testDisjunctionNullColl1 [label=" collectionA, iterableA, iterableB", dir=none];
getFromLinkedHashMap -> transform1 [label=" collectionA, iterableA, iterableB", dir=none];
getFromLinkedHashMap -> addAllForElements [label=" collectionA", dir=none];
getFromLinkedHashMap -> testDisjunctionNullColl2 [label=" collectionA, iterableA, iterableB", dir=none];
getFromLinkedHashMap -> getFromIterator [label=" collectionA, iterableA, iterableB", dir=none];
getFromLinkedHashMap -> getFromEnumeration [label=" collectionA, iterableA, iterableB", dir=none];
getFromLinkedHashMap -> testIntersectionNullColl2 [label=" collectionA, iterableA, iterableB", dir=none];
getFromLinkedHashMap -> getFromIterable [label=" collectionA, iterableA, iterableB", dir=none];
getFromLinkedHashMap -> getCardinalityMap [label=" collectionA, iterableA, iterableB", dir=none];
getFromLinkedHashMap -> testMatchesAll [label=" collectionA", dir=none];
getFromLinkedHashMap -> testRemoveRange [label=" collectionA, iterableA, iterableB", dir=none];
getFromLinkedHashMap -> get [label=" collectionA, iterableA, iterableB", dir=none];
getFromLinkedHashMap -> testIntersectionNullColl1 [label=" collectionA, iterableA, iterableB", dir=none];
getFromLinkedHashMap -> testRemoveCount [label=" collectionA, iterableA, iterableB", dir=none];
getFromLinkedHashMap -> testGetCardinalityMapNull [label=" collectionA, iterableA, iterableB", dir=none];
getFromLinkedHashMap -> intersectionUsesMethodEquals [label=" collectionA, iterableA, iterableB", dir=none];
getFromLinkedHashMap -> testIsProperSubCollection [label=" collectionA, iterableA, iterableB", dir=none];
getFromLinkedHashMap -> collateException1 [label=" collectionA", dir=none];
getFromLinkedHashMap -> collateException2 [label=" collectionA", dir=none];
getFromLinkedHashMap -> disjunction [label=" collectionA, iterableA, iterableB", dir=none];
getFromLinkedHashMap -> isEmpty [label=" collectionA", dir=none];
getFromLinkedHashMap -> forAllDoIterator [label=" collectionA", dir=none];
getFromLinkedHashMap -> getNegative [label=" collectionA, iterableA, iterableB", dir=none];
getFromLinkedHashMap -> forAllDoCollection [label=" collectionA", dir=none];
getFromLinkedHashMap -> union [label=" collectionA, iterableA, iterableB", dir=none];
getFromLinkedHashMap -> reverse [label=" collectionA", dir=none];
getFromLinkedHashMap -> cardinality [label=" iterableA, iterableB", dir=none];
getFromLinkedHashMap -> emptyIfNull [label=" collectionA", dir=none];
getFromLinkedHashMap -> filter [label=" collectionA, iterableA, iterableB", dir=none];
getFromLinkedHashMap -> testIsEmptyWithEmptyCollection [label=" collectionA", dir=none];
getFromLinkedHashMap -> getFromObject [label=" collectionA, iterableA, iterableB", dir=none];
getFromLinkedHashMap -> addAllForEnumeration [label=" collectionA", dir=none];
getFromLinkedHashMap -> testIsEqualCollection [label=" collectionA", dir=none];
getFromLinkedHashMap -> getFromList [label=" collectionA, iterableA, iterableB", dir=none];
getFromLinkedHashMap -> testDisjunctionAsUnionMinusIntersection [label=" collectionA, iterableA, iterableB", dir=none];
getIterator -> getCardinalityMap [label=" collectionA, iterableA, iterableB", dir=none];
getIterator -> addAllForEnumeration [label=" collectionA", dir=none];
getIterator -> disjunction [label=" collectionA, iterableA, iterableB", dir=none];
getIterator -> isEmpty [label=" collectionA", dir=none];
getIterator -> filterInverse [label=" collectionA, iterableA, iterableB", dir=none];
getIterator -> getFromObjectArray [label=" collectionA, iterableA, iterableB", dir=none];
getIterator -> testGetCardinalityMapNull [label=" collectionA, iterableA, iterableB", dir=none];
getIterator -> collect [label=" collectionA, iterableA", dir=none];
getIterator -> testDisjunctionAsUnionMinusIntersection [label=" collectionA, iterableA, iterableB", dir=none];
getIterator -> cardinality [label=" iterableA, iterableB", dir=none];
getIterator -> intersectionUsesMethodEquals [label=" collectionA, iterableA, iterableB", dir=none];
getFromMapIndexOutOfRange -> forAllButLastDoCollection [label=" collectionA", dir=none];
getFromMapIndexOutOfRange -> getFromPrimitiveArray [label=" collectionA, iterableA, iterableB", dir=none];
getFromMapIndexOutOfRange -> selectWithOutputCollections [label=" collectionA", dir=none];
getFromMapIndexOutOfRange -> testPermutations [label=" collectionA", dir=none];
getFromMapIndexOutOfRange -> testDisjunctionAsSymmetricDifference [label=" collectionA, iterableA, iterableB", dir=none];
getFromMapIndexOutOfRange -> find [label=" collectionA", dir=none];
getFromMapIndexOutOfRange -> getFromTreeMap [label=" collectionA, iterableA, iterableB", dir=none];
getFromMapIndexOutOfRange -> intersection [label=" collectionA, iterableA, iterableB", dir=none];
getFromMapIndexOutOfRange -> testIsSubCollection2 [label=" collectionA", dir=none];
getFromMapIndexOutOfRange -> testIsSubCollection [label=" collectionA", dir=none];
getFromMapIndexOutOfRange -> getEnumeration [label=" collectionA, iterableA, iterableB", dir=none];
getFromMapIndexOutOfRange -> testIsEqualCollectionReturnsFalse [label=" collectionA", dir=none];
getFromMapIndexOutOfRange -> getPositiveOutOfBounds [label=" collectionA, iterableA, iterableB", dir=none];
getFromMapIndexOutOfRange -> get1 [label=" collectionA, iterableA, iterableB", dir=none];
getFromMapIndexOutOfRange -> testIsSubCollectionOfSelf [label=" collectionA", dir=none];
getFromMapIndexOutOfRange -> testHashCode [label=" collectionA", dir=none];
getFromMapIndexOutOfRange -> cardinalityOfNull [label=" collectionA, iterableA, iterableB", dir=none];
getFromMapIndexOutOfRange -> testIsEmptyWithNonEmptyCollection [label=" collectionA", dir=none];
getFromMapIndexOutOfRange -> getIterator [label=" collectionA, iterableA, iterableB", dir=none];
getFromMapIndexOutOfRange -> filterInverse [label=" collectionA, iterableA, iterableB", dir=none];
getFromMapIndexOutOfRange -> getFromObjectArray [label=" collectionA, iterableA, iterableB", dir=none];
getFromMapIndexOutOfRange -> collect [label=" collectionA, iterableA", dir=none];
getFromMapIndexOutOfRange -> testIsEqualCollectionToSelf [label=" collectionA", dir=none];
getFromMapIndexOutOfRange -> testIsEqualCollectionNullEquator [label=" collectionA", dir=none];
getFromMapIndexOutOfRange -> filterNullParameters [label=" collectionA, iterableA, iterableB", dir=none];
getFromMapIndexOutOfRange -> forAllButLastDoIterator [label=" collectionA", dir=none];
getFromMapIndexOutOfRange -> testDisjunctionNullColl1 [label=" collectionA, iterableA, iterableB", dir=none];
getFromMapIndexOutOfRange -> transform1 [label=" collectionA, iterableA, iterableB", dir=none];
getFromMapIndexOutOfRange -> addAllForElements [label=" collectionA", dir=none];
getFromMapIndexOutOfRange -> testDisjunctionNullColl2 [label=" collectionA, iterableA, iterableB", dir=none];
getFromMapIndexOutOfRange -> getFromIterator [label=" collectionA, iterableA, iterableB", dir=none];
getFromMapIndexOutOfRange -> getFromEnumeration [label=" collectionA, iterableA, iterableB", dir=none];
getFromMapIndexOutOfRange -> testIntersectionNullColl2 [label=" collectionA, iterableA, iterableB", dir=none];
getFromMapIndexOutOfRange -> getFromIterable [label=" collectionA, iterableA, iterableB", dir=none];
getFromMapIndexOutOfRange -> getCardinalityMap [label=" collectionA, iterableA, iterableB", dir=none];
getFromMapIndexOutOfRange -> testMatchesAll [label=" collectionA", dir=none];
getFromMapIndexOutOfRange -> testRemoveRange [label=" collectionA, iterableA, iterableB", dir=none];
getFromMapIndexOutOfRange -> get [label=" collectionA, iterableA, iterableB", dir=none];
getFromMapIndexOutOfRange -> testIntersectionNullColl1 [label=" collectionA, iterableA, iterableB", dir=none];
getFromMapIndexOutOfRange -> testRemoveCount [label=" collectionA, iterableA, iterableB", dir=none];
getFromMapIndexOutOfRange -> testGetCardinalityMapNull [label=" collectionA, iterableA, iterableB", dir=none];
getFromMapIndexOutOfRange -> intersectionUsesMethodEquals [label=" collectionA, iterableA, iterableB", dir=none];
getFromMapIndexOutOfRange -> testIsProperSubCollection [label=" collectionA, iterableA, iterableB", dir=none];
getFromMapIndexOutOfRange -> collateException1 [label=" collectionA", dir=none];
getFromMapIndexOutOfRange -> collateException2 [label=" collectionA", dir=none];
getFromMapIndexOutOfRange -> disjunction [label=" collectionA, iterableA, iterableB", dir=none];
getFromMapIndexOutOfRange -> isEmpty [label=" collectionA", dir=none];
getFromMapIndexOutOfRange -> forAllDoIterator [label=" collectionA", dir=none];
getFromMapIndexOutOfRange -> getNegative [label=" collectionA, iterableA, iterableB", dir=none];
getFromMapIndexOutOfRange -> forAllDoCollection [label=" collectionA", dir=none];
getFromMapIndexOutOfRange -> union [label=" collectionA, iterableA, iterableB", dir=none];
getFromMapIndexOutOfRange -> reverse [label=" collectionA", dir=none];
getFromMapIndexOutOfRange -> cardinality [label=" iterableA, iterableB", dir=none];
getFromMapIndexOutOfRange -> emptyIfNull [label=" collectionA", dir=none];
getFromMapIndexOutOfRange -> filter [label=" collectionA, iterableA, iterableB", dir=none];
getFromMapIndexOutOfRange -> testIsEmptyWithEmptyCollection [label=" collectionA", dir=none];
getFromMapIndexOutOfRange -> getFromObject [label=" collectionA, iterableA, iterableB", dir=none];
getFromMapIndexOutOfRange -> addAllForEnumeration [label=" collectionA", dir=none];
getFromMapIndexOutOfRange -> testIsEqualCollection [label=" collectionA", dir=none];
getFromMapIndexOutOfRange -> getFromList [label=" collectionA, iterableA, iterableB", dir=none];
getFromMapIndexOutOfRange -> testDisjunctionAsUnionMinusIntersection [label=" collectionA, iterableA, iterableB", dir=none];
filterInverse -> getCardinalityMap [label=" collectionA, iterableA, iterableB", dir=none];
filterInverse -> addAllForEnumeration [label=" collectionA", dir=none];
filterInverse -> disjunction [label=" collectionA, iterableA, iterableB", dir=none];
filterInverse -> selectRejected [label=" EQUALS_TWO", dir=none];
filterInverse -> isEmpty [label=" collectionA", dir=none];
filterInverse -> getFromObjectArray [label=" collectionA, iterableA, iterableB", dir=none];
filterInverse -> testGetCardinalityMapNull [label=" collectionA, iterableA, iterableB", dir=none];
filterInverse -> collect [label=" collectionA, iterableA", dir=none];
filterInverse -> testDisjunctionAsUnionMinusIntersection [label=" collectionA, iterableA, iterableB", dir=none];
filterInverse -> cardinality [label=" iterableA, iterableB", dir=none];
filterInverse -> intersectionUsesMethodEquals [label=" collectionA, iterableA, iterableB", dir=none];
getFromObjectArray -> getCardinalityMap [label=" collectionA, iterableA, iterableB", dir=none];
getFromObjectArray -> addAllForEnumeration [label=" collectionA", dir=none];
getFromObjectArray -> disjunction [label=" collectionA, iterableA, iterableB", dir=none];
getFromObjectArray -> isEmpty [label=" collectionA", dir=none];
getFromObjectArray -> testGetCardinalityMapNull [label=" collectionA, iterableA, iterableB", dir=none];
getFromObjectArray -> collect [label=" collectionA, iterableA", dir=none];
getFromObjectArray -> testDisjunctionAsUnionMinusIntersection [label=" collectionA, iterableA, iterableB", dir=none];
getFromObjectArray -> cardinality [label=" iterableA, iterableB", dir=none];
getFromObjectArray -> intersectionUsesMethodEquals [label=" collectionA, iterableA, iterableB", dir=none];
collect -> getCardinalityMap [label=" iterableA, collectionA", dir=none];
collect -> addAllForEnumeration [label=" collectionA", dir=none];
collect -> disjunction [label=" iterableA, collectionA", dir=none];
collect -> isEmpty [label=" collectionA", dir=none];
collect -> testGetCardinalityMapNull [label=" iterableA, collectionA", dir=none];
collect -> testDisjunctionAsUnionMinusIntersection [label=" iterableA, collectionA", dir=none];
collect -> cardinality [label=" iterableA", dir=none];
collect -> intersectionUsesMethodEquals [label=" iterableA, collectionA", dir=none];
testIsEqualCollectionToSelf -> forAllButLastDoCollection [label=" collectionA, collectionB", dir=none];
testIsEqualCollectionToSelf -> getFromPrimitiveArray [label=" collectionA", dir=none];
testIsEqualCollectionToSelf -> selectWithOutputCollections [label=" collectionA", dir=none];
testIsEqualCollectionToSelf -> testPermutations [label=" collectionA", dir=none];
testIsEqualCollectionToSelf -> testDisjunctionAsSymmetricDifference [label=" collectionA", dir=none];
testIsEqualCollectionToSelf -> find [label=" collectionA", dir=none];
testIsEqualCollectionToSelf -> getFromTreeMap [label=" collectionA", dir=none];
testIsEqualCollectionToSelf -> intersection [label=" collectionA", dir=none];
testIsEqualCollectionToSelf -> testIsSubCollection2 [label=" collectionA", dir=none];
testIsEqualCollectionToSelf -> testIsSubCollection [label=" collectionA", dir=none];
testIsEqualCollectionToSelf -> getEnumeration [label=" collectionA", dir=none];
testIsEqualCollectionToSelf -> testIsEqualCollectionReturnsFalse [label=" collectionA", dir=none];
testIsEqualCollectionToSelf -> getPositiveOutOfBounds [label=" collectionA", dir=none];
testIsEqualCollectionToSelf -> get1 [label=" collectionA", dir=none];
testIsEqualCollectionToSelf -> testIsSubCollectionOfSelf [label=" collectionA, collectionB", dir=none];
testIsEqualCollectionToSelf -> testHashCode [label=" collectionA", dir=none];
testIsEqualCollectionToSelf -> cardinalityOfNull [label=" collectionA", dir=none];
testIsEqualCollectionToSelf -> testIsEmptyWithNonEmptyCollection [label=" collectionA", dir=none];
testIsEqualCollectionToSelf -> getIterator [label=" collectionA", dir=none];
testIsEqualCollectionToSelf -> filterInverse [label=" collectionA", dir=none];
testIsEqualCollectionToSelf -> getFromObjectArray [label=" collectionA", dir=none];
testIsEqualCollectionToSelf -> collect [label=" collectionA, collectionB", dir=none];
testIsEqualCollectionToSelf -> testIsEqualCollectionNullEquator [label=" collectionA", dir=none];
testIsEqualCollectionToSelf -> filterNullParameters [label=" collectionA", dir=none];
testIsEqualCollectionToSelf -> forAllButLastDoIterator [label=" collectionA, collectionB", dir=none];
testIsEqualCollectionToSelf -> testDisjunctionNullColl1 [label=" collectionA", dir=none];
testIsEqualCollectionToSelf -> transform1 [label=" collectionA", dir=none];
testIsEqualCollectionToSelf -> addAllForElements [label=" collectionA", dir=none];
testIsEqualCollectionToSelf -> testDisjunctionNullColl2 [label=" collectionA", dir=none];
testIsEqualCollectionToSelf -> getFromIterator [label=" collectionA", dir=none];
testIsEqualCollectionToSelf -> getFromEnumeration [label=" collectionA", dir=none];
testIsEqualCollectionToSelf -> testIntersectionNullColl2 [label=" collectionA", dir=none];
testIsEqualCollectionToSelf -> getFromIterable [label=" collectionA", dir=none];
testIsEqualCollectionToSelf -> getCardinalityMap [label=" collectionA", dir=none];
testIsEqualCollectionToSelf -> testMatchesAll [label=" collectionA", dir=none];
testIsEqualCollectionToSelf -> testRemoveRange [label=" collectionA", dir=none];
testIsEqualCollectionToSelf -> get [label=" collectionA", dir=none];
testIsEqualCollectionToSelf -> testIntersectionNullColl1 [label=" collectionA", dir=none];
testIsEqualCollectionToSelf -> testRemoveCount [label=" collectionA", dir=none];
testIsEqualCollectionToSelf -> testGetCardinalityMapNull [label=" collectionA", dir=none];
testIsEqualCollectionToSelf -> intersectionUsesMethodEquals [label=" collectionA", dir=none];
testIsEqualCollectionToSelf -> testIsProperSubCollection [label=" collectionA", dir=none];
testIsEqualCollectionToSelf -> collateException1 [label=" collectionA", dir=none];
testIsEqualCollectionToSelf -> collateException2 [label=" collectionA", dir=none];
testIsEqualCollectionToSelf -> disjunction [label=" collectionA", dir=none];
testIsEqualCollectionToSelf -> isEmpty [label=" collectionA", dir=none];
testIsEqualCollectionToSelf -> forAllDoIterator [label=" collectionA", dir=none];
testIsEqualCollectionToSelf -> getNegative [label=" collectionA", dir=none];
testIsEqualCollectionToSelf -> forAllDoCollection [label=" collectionA", dir=none];
testIsEqualCollectionToSelf -> union [label=" collectionA", dir=none];
testIsEqualCollectionToSelf -> reverse [label=" collectionA", dir=none];
testIsEqualCollectionToSelf -> emptyIfNull [label=" collectionA", dir=none];
testIsEqualCollectionToSelf -> filter [label=" collectionA", dir=none];
testIsEqualCollectionToSelf -> testIsEmptyWithEmptyCollection [label=" collectionA", dir=none];
testIsEqualCollectionToSelf -> getFromObject [label=" collectionA", dir=none];
testIsEqualCollectionToSelf -> addAllForEnumeration [label=" collectionA", dir=none];
testIsEqualCollectionToSelf -> testIsEqualCollection [label=" collectionA", dir=none];
testIsEqualCollectionToSelf -> getFromList [label=" collectionA", dir=none];
testIsEqualCollectionToSelf -> testDisjunctionAsUnionMinusIntersection [label=" collectionA", dir=none];
testIsEqualCollectionNullEquator -> forAllButLastDoCollection [label=" collectionA", dir=none];
testIsEqualCollectionNullEquator -> getFromPrimitiveArray [label=" collectionA", dir=none];
testIsEqualCollectionNullEquator -> selectWithOutputCollections [label=" collectionA", dir=none];
testIsEqualCollectionNullEquator -> testPermutations [label=" collectionA", dir=none];
testIsEqualCollectionNullEquator -> testDisjunctionAsSymmetricDifference [label=" collectionA", dir=none];
testIsEqualCollectionNullEquator -> find [label=" collectionA", dir=none];
testIsEqualCollectionNullEquator -> getFromTreeMap [label=" collectionA", dir=none];
testIsEqualCollectionNullEquator -> intersection [label=" collectionA", dir=none];
testIsEqualCollectionNullEquator -> testIsSubCollection2 [label=" collectionA", dir=none];
testIsEqualCollectionNullEquator -> testIsSubCollection [label=" collectionA", dir=none];
testIsEqualCollectionNullEquator -> getEnumeration [label=" collectionA", dir=none];
testIsEqualCollectionNullEquator -> testIsEqualCollectionReturnsFalse [label=" collectionA", dir=none];
testIsEqualCollectionNullEquator -> getPositiveOutOfBounds [label=" collectionA", dir=none];
testIsEqualCollectionNullEquator -> get1 [label=" collectionA", dir=none];
testIsEqualCollectionNullEquator -> testIsSubCollectionOfSelf [label=" collectionA", dir=none];
testIsEqualCollectionNullEquator -> testHashCode [label=" collectionA", dir=none];
testIsEqualCollectionNullEquator -> cardinalityOfNull [label=" collectionA", dir=none];
testIsEqualCollectionNullEquator -> testIsEmptyWithNonEmptyCollection [label=" collectionA", dir=none];
testIsEqualCollectionNullEquator -> getIterator [label=" collectionA", dir=none];
testIsEqualCollectionNullEquator -> filterInverse [label=" collectionA", dir=none];
testIsEqualCollectionNullEquator -> getFromObjectArray [label=" collectionA", dir=none];
testIsEqualCollectionNullEquator -> collect [label=" collectionA", dir=none];
testIsEqualCollectionNullEquator -> filterNullParameters [label=" collectionA", dir=none];
testIsEqualCollectionNullEquator -> forAllButLastDoIterator [label=" collectionA", dir=none];
testIsEqualCollectionNullEquator -> testDisjunctionNullColl1 [label=" collectionA", dir=none];
testIsEqualCollectionNullEquator -> transform1 [label=" collectionA", dir=none];
testIsEqualCollectionNullEquator -> addAllForElements [label=" collectionA", dir=none];
testIsEqualCollectionNullEquator -> testDisjunctionNullColl2 [label=" collectionA", dir=none];
testIsEqualCollectionNullEquator -> getFromIterator [label=" collectionA", dir=none];
testIsEqualCollectionNullEquator -> getFromEnumeration [label=" collectionA", dir=none];
testIsEqualCollectionNullEquator -> testIntersectionNullColl2 [label=" collectionA", dir=none];
testIsEqualCollectionNullEquator -> getFromIterable [label=" collectionA", dir=none];
testIsEqualCollectionNullEquator -> getCardinalityMap [label=" collectionA", dir=none];
testIsEqualCollectionNullEquator -> testMatchesAll [label=" collectionA", dir=none];
testIsEqualCollectionNullEquator -> testRemoveRange [label=" collectionA", dir=none];
testIsEqualCollectionNullEquator -> get [label=" collectionA", dir=none];
testIsEqualCollectionNullEquator -> testIntersectionNullColl1 [label=" collectionA", dir=none];
testIsEqualCollectionNullEquator -> testRemoveCount [label=" collectionA", dir=none];
testIsEqualCollectionNullEquator -> testGetCardinalityMapNull [label=" collectionA", dir=none];
testIsEqualCollectionNullEquator -> intersectionUsesMethodEquals [label=" collectionA", dir=none];
testIsEqualCollectionNullEquator -> testIsProperSubCollection [label=" collectionA", dir=none];
testIsEqualCollectionNullEquator -> collateException1 [label=" collectionA", dir=none];
testIsEqualCollectionNullEquator -> collateException2 [label=" collectionA", dir=none];
testIsEqualCollectionNullEquator -> disjunction [label=" collectionA", dir=none];
testIsEqualCollectionNullEquator -> isEmpty [label=" collectionA", dir=none];
testIsEqualCollectionNullEquator -> forAllDoIterator [label=" collectionA", dir=none];
testIsEqualCollectionNullEquator -> getNegative [label=" collectionA", dir=none];
testIsEqualCollectionNullEquator -> forAllDoCollection [label=" collectionA", dir=none];
testIsEqualCollectionNullEquator -> union [label=" collectionA", dir=none];
testIsEqualCollectionNullEquator -> reverse [label=" collectionA", dir=none];
testIsEqualCollectionNullEquator -> emptyIfNull [label=" collectionA", dir=none];
testIsEqualCollectionNullEquator -> filter [label=" collectionA", dir=none];
testIsEqualCollectionNullEquator -> testIsEmptyWithEmptyCollection [label=" collectionA", dir=none];
testIsEqualCollectionNullEquator -> getFromObject [label=" collectionA", dir=none];
testIsEqualCollectionNullEquator -> addAllForEnumeration [label=" collectionA", dir=none];
testIsEqualCollectionNullEquator -> testIsEqualCollection [label=" collectionA", dir=none];
testIsEqualCollectionNullEquator -> getFromList [label=" collectionA", dir=none];
testIsEqualCollectionNullEquator -> testDisjunctionAsUnionMinusIntersection [label=" collectionA", dir=none];
filterNullParameters -> forAllButLastDoCollection [label=" collectionA", dir=none];
filterNullParameters -> getFromPrimitiveArray [label=" collectionA, iterableA, iterableB", dir=none];
filterNullParameters -> selectWithOutputCollections [label=" collectionA, EQUALS_TWO", dir=none];
filterNullParameters -> testPermutations [label=" collectionA", dir=none];
filterNullParameters -> testDisjunctionAsSymmetricDifference [label=" collectionA, iterableA, iterableB", dir=none];
filterNullParameters -> find [label=" collectionA", dir=none];
filterNullParameters -> getFromTreeMap [label=" collectionA, iterableA, iterableB", dir=none];
filterNullParameters -> intersection [label=" collectionA, iterableA, iterableB", dir=none];
filterNullParameters -> testIsSubCollection2 [label=" collectionA", dir=none];
filterNullParameters -> testIsSubCollection [label=" collectionA", dir=none];
filterNullParameters -> getEnumeration [label=" collectionA, iterableA, iterableB", dir=none];
filterNullParameters -> testIsEqualCollectionReturnsFalse [label=" collectionA", dir=none];
filterNullParameters -> getPositiveOutOfBounds [label=" collectionA, iterableA, iterableB", dir=none];
filterNullParameters -> get1 [label=" collectionA, iterableA, iterableB", dir=none];
filterNullParameters -> testIsSubCollectionOfSelf [label=" collectionA", dir=none];
filterNullParameters -> testHashCode [label=" collectionA", dir=none];
filterNullParameters -> cardinalityOfNull [label=" collectionA, iterableA, iterableB", dir=none];
filterNullParameters -> testIsEmptyWithNonEmptyCollection [label=" collectionA", dir=none];
filterNullParameters -> getIterator [label=" collectionA, iterableA, iterableB", dir=none];
filterNullParameters -> filterInverse [label=" collectionA, iterableA, EQUALS_TWO, iterableB", dir=none];
filterNullParameters -> getFromObjectArray [label=" collectionA, iterableA, iterableB", dir=none];
filterNullParameters -> collect [label=" collectionA, iterableA", dir=none];
filterNullParameters -> forAllButLastDoIterator [label=" collectionA", dir=none];
filterNullParameters -> testDisjunctionNullColl1 [label=" collectionA, iterableA, iterableB", dir=none];
filterNullParameters -> transform1 [label=" collectionA, iterableA, iterableB", dir=none];
filterNullParameters -> addAllForElements [label=" collectionA", dir=none];
filterNullParameters -> testDisjunctionNullColl2 [label=" collectionA, iterableA, iterableB", dir=none];
filterNullParameters -> getFromIterator [label=" collectionA, iterableA, iterableB", dir=none];
filterNullParameters -> getFromEnumeration [label=" collectionA, iterableA, iterableB", dir=none];
filterNullParameters -> testIntersectionNullColl2 [label=" collectionA, iterableA, iterableB", dir=none];
filterNullParameters -> getFromIterable [label=" collectionA, iterableA, iterableB", dir=none];
filterNullParameters -> getCardinalityMap [label=" collectionA, iterableA, iterableB", dir=none];
filterNullParameters -> testMatchesAll [label=" collectionA", dir=none];
filterNullParameters -> testRemoveRange [label=" collectionA, iterableA, iterableB", dir=none];
filterNullParameters -> get [label=" collectionA, iterableA, iterableB", dir=none];
filterNullParameters -> testIntersectionNullColl1 [label=" collectionA, iterableA, iterableB", dir=none];
filterNullParameters -> testRemoveCount [label=" collectionA, iterableA, iterableB", dir=none];
filterNullParameters -> testGetCardinalityMapNull [label=" collectionA, iterableA, iterableB", dir=none];
filterNullParameters -> intersectionUsesMethodEquals [label=" collectionA, iterableA, iterableB", dir=none];
filterNullParameters -> testIsProperSubCollection [label=" collectionA, iterableA, iterableB", dir=none];
filterNullParameters -> collateException1 [label=" collectionA", dir=none];
filterNullParameters -> collateException2 [label=" collectionA", dir=none];
filterNullParameters -> disjunction [label=" collectionA, iterableA, iterableB", dir=none];
filterNullParameters -> selectRejected [label=" EQUALS_TWO", dir=none];
filterNullParameters -> isEmpty [label=" collectionA", dir=none];
filterNullParameters -> forAllDoIterator [label=" collectionA", dir=none];
filterNullParameters -> getNegative [label=" collectionA, iterableA, iterableB", dir=none];
filterNullParameters -> forAllDoCollection [label=" collectionA", dir=none];
filterNullParameters -> union [label=" collectionA, iterableA, iterableB", dir=none];
filterNullParameters -> reverse [label=" collectionA", dir=none];
filterNullParameters -> cardinality [label=" iterableA, iterableB", dir=none];
filterNullParameters -> emptyIfNull [label=" collectionA", dir=none];
filterNullParameters -> filter [label=" collectionA, iterableA, EQUALS_TWO, iterableB", dir=none];
filterNullParameters -> testIsEmptyWithEmptyCollection [label=" collectionA", dir=none];
filterNullParameters -> getFromObject [label=" collectionA, iterableA, iterableB", dir=none];
filterNullParameters -> addAllForEnumeration [label=" collectionA", dir=none];
filterNullParameters -> testIsEqualCollection [label=" collectionA", dir=none];
filterNullParameters -> getFromList [label=" collectionA, iterableA, iterableB", dir=none];
filterNullParameters -> exists [label=" EQUALS_TWO", dir=none];
filterNullParameters -> testDisjunctionAsUnionMinusIntersection [label=" collectionA, iterableA, iterableB", dir=none];
forAllButLastDoIterator -> forAllButLastDoCollection [label=" collectionA, collectionB", dir=none];
forAllButLastDoIterator -> getFromPrimitiveArray [label=" collectionA", dir=none];
forAllButLastDoIterator -> selectWithOutputCollections [label=" collectionA", dir=none];
forAllButLastDoIterator -> testPermutations [label=" collectionA", dir=none];
forAllButLastDoIterator -> testDisjunctionAsSymmetricDifference [label=" collectionA", dir=none];
forAllButLastDoIterator -> find [label=" collectionA", dir=none];
forAllButLastDoIterator -> getFromTreeMap [label=" collectionA", dir=none];
forAllButLastDoIterator -> intersection [label=" collectionA", dir=none];
forAllButLastDoIterator -> testIsSubCollection2 [label=" collectionA", dir=none];
forAllButLastDoIterator -> testIsSubCollection [label=" collectionA", dir=none];
forAllButLastDoIterator -> getEnumeration [label=" collectionA", dir=none];
forAllButLastDoIterator -> testIsEqualCollectionReturnsFalse [label=" collectionA", dir=none];
forAllButLastDoIterator -> getPositiveOutOfBounds [label=" collectionA", dir=none];
forAllButLastDoIterator -> get1 [label=" collectionA", dir=none];
forAllButLastDoIterator -> testIsSubCollectionOfSelf [label=" collectionA, collectionB", dir=none];
forAllButLastDoIterator -> testHashCode [label=" collectionA", dir=none];
forAllButLastDoIterator -> cardinalityOfNull [label=" collectionA", dir=none];
forAllButLastDoIterator -> testIsEmptyWithNonEmptyCollection [label=" collectionA", dir=none];
forAllButLastDoIterator -> getIterator [label=" collectionA", dir=none];
forAllButLastDoIterator -> filterInverse [label=" collectionA", dir=none];
forAllButLastDoIterator -> getFromObjectArray [label=" collectionA", dir=none];
forAllButLastDoIterator -> collect [label=" collectionA, collectionB", dir=none];
forAllButLastDoIterator -> testDisjunctionNullColl1 [label=" collectionA", dir=none];
forAllButLastDoIterator -> transform1 [label=" collectionA", dir=none];
forAllButLastDoIterator -> addAllForElements [label=" collectionA", dir=none];
forAllButLastDoIterator -> testDisjunctionNullColl2 [label=" collectionA", dir=none];
forAllButLastDoIterator -> getFromIterator [label=" collectionA", dir=none];
forAllButLastDoIterator -> getFromEnumeration [label=" collectionA", dir=none];
forAllButLastDoIterator -> testIntersectionNullColl2 [label=" collectionA", dir=none];
forAllButLastDoIterator -> getFromIterable [label=" collectionA", dir=none];
forAllButLastDoIterator -> getCardinalityMap [label=" collectionA", dir=none];
forAllButLastDoIterator -> testMatchesAll [label=" collectionA", dir=none];
forAllButLastDoIterator -> testRemoveRange [label=" collectionA", dir=none];
forAllButLastDoIterator -> get [label=" collectionA", dir=none];
forAllButLastDoIterator -> testIntersectionNullColl1 [label=" collectionA", dir=none];
forAllButLastDoIterator -> testRemoveCount [label=" collectionA", dir=none];
forAllButLastDoIterator -> testGetCardinalityMapNull [label=" collectionA", dir=none];
forAllButLastDoIterator -> intersectionUsesMethodEquals [label=" collectionA", dir=none];
forAllButLastDoIterator -> testIsProperSubCollection [label=" collectionA", dir=none];
forAllButLastDoIterator -> collateException1 [label=" collectionA", dir=none];
forAllButLastDoIterator -> collateException2 [label=" collectionA", dir=none];
forAllButLastDoIterator -> disjunction [label=" collectionA", dir=none];
forAllButLastDoIterator -> isEmpty [label=" collectionA", dir=none];
forAllButLastDoIterator -> forAllDoIterator [label=" collectionA", dir=none];
forAllButLastDoIterator -> getNegative [label=" collectionA", dir=none];
forAllButLastDoIterator -> forAllDoCollection [label=" collectionA", dir=none];
forAllButLastDoIterator -> union [label=" collectionA", dir=none];
forAllButLastDoIterator -> reverse [label=" collectionA", dir=none];
forAllButLastDoIterator -> emptyIfNull [label=" collectionA", dir=none];
forAllButLastDoIterator -> filter [label=" collectionA", dir=none];
forAllButLastDoIterator -> testIsEmptyWithEmptyCollection [label=" collectionA", dir=none];
forAllButLastDoIterator -> getFromObject [label=" collectionA", dir=none];
forAllButLastDoIterator -> addAllForEnumeration [label=" collectionA", dir=none];
forAllButLastDoIterator -> testIsEqualCollection [label=" collectionA", dir=none];
forAllButLastDoIterator -> getFromList [label=" collectionA", dir=none];
forAllButLastDoIterator -> testDisjunctionAsUnionMinusIntersection [label=" collectionA", dir=none];
testDisjunctionNullColl1 -> forAllButLastDoCollection [label=" collectionA", dir=none];
testDisjunctionNullColl1 -> getFromPrimitiveArray [label=" iterableA, collectionA, iterableB", dir=none];
testDisjunctionNullColl1 -> selectWithOutputCollections [label=" collectionA", dir=none];
testDisjunctionNullColl1 -> testPermutations [label=" collectionA", dir=none];
testDisjunctionNullColl1 -> testDisjunctionAsSymmetricDifference [label=" iterableA, collectionA, collectionC2, iterableB, iterableC", dir=none];
testDisjunctionNullColl1 -> find [label=" collectionA", dir=none];
testDisjunctionNullColl1 -> getFromTreeMap [label=" iterableA, collectionA, iterableB", dir=none];
testDisjunctionNullColl1 -> intersection [label=" iterableA, collectionA, collectionC2, iterableB, iterableC", dir=none];
testDisjunctionNullColl1 -> testIsSubCollection2 [label=" collectionA", dir=none];
testDisjunctionNullColl1 -> testIsSubCollection [label=" collectionA", dir=none];
testDisjunctionNullColl1 -> getEnumeration [label=" iterableA, collectionA, iterableB", dir=none];
testDisjunctionNullColl1 -> testIsEqualCollectionReturnsFalse [label=" collectionA", dir=none];
testDisjunctionNullColl1 -> getPositiveOutOfBounds [label=" iterableA, collectionA, iterableB", dir=none];
testDisjunctionNullColl1 -> get1 [label=" iterableA, collectionA, iterableB", dir=none];
testDisjunctionNullColl1 -> testIsSubCollectionOfSelf [label=" collectionA", dir=none];
testDisjunctionNullColl1 -> testHashCode [label=" collectionA", dir=none];
testDisjunctionNullColl1 -> cardinalityOfNull [label=" iterableA, collectionA, iterableB", dir=none];
testDisjunctionNullColl1 -> testIsEmptyWithNonEmptyCollection [label=" collectionA", dir=none];
testDisjunctionNullColl1 -> getIterator [label=" iterableA, collectionA, iterableB", dir=none];
testDisjunctionNullColl1 -> filterInverse [label=" iterableA, collectionA, iterableB", dir=none];
testDisjunctionNullColl1 -> getFromObjectArray [label=" iterableA, collectionA, iterableB", dir=none];
testDisjunctionNullColl1 -> collect [label=" iterableA, collectionA", dir=none];
testDisjunctionNullColl1 -> transform1 [label=" iterableA, collectionA, iterableB", dir=none];
testDisjunctionNullColl1 -> addAllForElements [label=" collectionA", dir=none];
testDisjunctionNullColl1 -> testDisjunctionNullColl2 [label=" iterableA, collectionA, collectionC2, iterableB, iterableC", dir=none];
testDisjunctionNullColl1 -> getFromIterator [label=" iterableA, collectionA, iterableB", dir=none];
testDisjunctionNullColl1 -> getFromEnumeration [label=" iterableA, collectionA, iterableB", dir=none];
testDisjunctionNullColl1 -> testIntersectionNullColl2 [label=" iterableA, collectionA, collectionC2, iterableB, iterableC", dir=none];
testDisjunctionNullColl1 -> getFromIterable [label=" iterableA, collectionA, iterableB", dir=none];
testDisjunctionNullColl1 -> getCardinalityMap [label=" iterableA, collectionA, iterableB", dir=none];
testDisjunctionNullColl1 -> testMatchesAll [label=" collectionA", dir=none];
testDisjunctionNullColl1 -> testRemoveRange [label=" iterableA, collectionA, iterableB", dir=none];
testDisjunctionNullColl1 -> get [label=" iterableA, collectionA, iterableB", dir=none];
testDisjunctionNullColl1 -> testIntersectionNullColl1 [label=" iterableA, collectionA, collectionC2, iterableB, iterableC", dir=none];
testDisjunctionNullColl1 -> testRemoveCount [label=" iterableA, collectionA, iterableB", dir=none];
testDisjunctionNullColl1 -> testGetCardinalityMapNull [label=" iterableA, collectionA, iterableB", dir=none];
testDisjunctionNullColl1 -> intersectionUsesMethodEquals [label=" iterableA, collectionA, collectionC2, iterableB, iterableC", dir=none];
testDisjunctionNullColl1 -> testIsProperSubCollection [label=" iterableA, collectionA, collectionC2, iterableB, iterableC", dir=none];
testDisjunctionNullColl1 -> collateException1 [label=" collectionA", dir=none];
testDisjunctionNullColl1 -> collateException2 [label=" collectionA", dir=none];
testDisjunctionNullColl1 -> disjunction [label=" iterableA, collectionA, collectionC2, iterableB, iterableC", dir=none];
testDisjunctionNullColl1 -> isEmpty [label=" collectionA", dir=none];
testDisjunctionNullColl1 -> forAllDoIterator [label=" collectionA", dir=none];
testDisjunctionNullColl1 -> getNegative [label=" iterableA, collectionA, iterableB", dir=none];
testDisjunctionNullColl1 -> forAllDoCollection [label=" collectionA", dir=none];
testDisjunctionNullColl1 -> union [label=" iterableA, collectionA, collectionC2, iterableB, iterableC", dir=none];
testDisjunctionNullColl1 -> reverse [label=" collectionA", dir=none];
testDisjunctionNullColl1 -> cardinality [label=" iterableA, iterableB", dir=none];
testDisjunctionNullColl1 -> emptyIfNull [label=" collectionA", dir=none];
testDisjunctionNullColl1 -> filter [label=" iterableA, collectionA, iterableB", dir=none];
testDisjunctionNullColl1 -> testIsEmptyWithEmptyCollection [label=" collectionA", dir=none];
testDisjunctionNullColl1 -> getFromObject [label=" iterableA, collectionA, iterableB", dir=none];
testDisjunctionNullColl1 -> addAllForEnumeration [label=" collectionA", dir=none];
testDisjunctionNullColl1 -> testIsEqualCollection [label=" collectionA", dir=none];
testDisjunctionNullColl1 -> getFromList [label=" iterableA, collectionA, iterableB", dir=none];
testDisjunctionNullColl1 -> testDisjunctionAsUnionMinusIntersection [label=" iterableA, collectionA, collectionC2, iterableB, iterableC", dir=none];
transform1 -> forAllButLastDoCollection [label=" collectionA", dir=none];
transform1 -> getFromPrimitiveArray [label=" collectionA, iterableA, iterableB", dir=none];
transform1 -> selectWithOutputCollections [label=" collectionA", dir=none];
transform1 -> testPermutations [label=" collectionA", dir=none];
transform1 -> testDisjunctionAsSymmetricDifference [label=" collectionA, iterableA, iterableB", dir=none];
transform1 -> find [label=" collectionA", dir=none];
transform1 -> getFromTreeMap [label=" collectionA, iterableA, iterableB", dir=none];
transform1 -> intersection [label=" collectionA, iterableA, iterableB", dir=none];
transform1 -> testIsSubCollection2 [label=" collectionA", dir=none];
transform1 -> testIsSubCollection [label=" collectionA", dir=none];
transform1 -> getEnumeration [label=" collectionA, iterableA, iterableB", dir=none];
transform1 -> testIsEqualCollectionReturnsFalse [label=" collectionA", dir=none];
transform1 -> getPositiveOutOfBounds [label=" collectionA, iterableA, iterableB", dir=none];
transform1 -> get1 [label=" collectionA, iterableA, iterableB", dir=none];
transform1 -> testIsSubCollectionOfSelf [label=" collectionA", dir=none];
transform1 -> testHashCode [label=" collectionA", dir=none];
transform1 -> cardinalityOfNull [label=" collectionA, iterableA, iterableB", dir=none];
transform1 -> testIsEmptyWithNonEmptyCollection [label=" collectionA", dir=none];
transform1 -> getIterator [label=" collectionA, iterableA, iterableB", dir=none];
transform1 -> filterInverse [label=" collectionA, iterableA, iterableB", dir=none];
transform1 -> getFromObjectArray [label=" collectionA, iterableA, iterableB", dir=none];
transform1 -> collect [label=" collectionA, iterableA", dir=none];
transform1 -> addAllForElements [label=" collectionA", dir=none];
transform1 -> testDisjunctionNullColl2 [label=" collectionA, iterableA, iterableB", dir=none];
transform1 -> getFromIterator [label=" collectionA, iterableA, iterableB", dir=none];
transform1 -> getFromEnumeration [label=" collectionA, iterableA, iterableB", dir=none];
transform1 -> testIntersectionNullColl2 [label=" collectionA, iterableA, iterableB", dir=none];
transform1 -> getFromIterable [label=" collectionA, iterableA, iterableB", dir=none];
transform1 -> getCardinalityMap [label=" collectionA, iterableA, iterableB", dir=none];
transform1 -> testMatchesAll [label=" collectionA", dir=none];
transform1 -> testRemoveRange [label=" collectionA, iterableA, iterableB", dir=none];
transform1 -> get [label=" collectionA, iterableA, iterableB", dir=none];
transform1 -> testIntersectionNullColl1 [label=" collectionA, iterableA, iterableB", dir=none];
transform1 -> testRemoveCount [label=" collectionA, iterableA, iterableB", dir=none];
transform1 -> testGetCardinalityMapNull [label=" collectionA, iterableA, iterableB", dir=none];
transform1 -> intersectionUsesMethodEquals [label=" collectionA, iterableA, iterableB", dir=none];
transform1 -> testIsProperSubCollection [label=" collectionA, iterableA, iterableB", dir=none];
transform1 -> collateException1 [label=" collectionA", dir=none];
transform1 -> collateException2 [label=" collectionA", dir=none];
transform1 -> disjunction [label=" collectionA, iterableA, iterableB", dir=none];
transform1 -> isEmpty [label=" collectionA", dir=none];
transform1 -> forAllDoIterator [label=" collectionA", dir=none];
transform1 -> getNegative [label=" collectionA, iterableA, iterableB", dir=none];
transform1 -> forAllDoCollection [label=" collectionA", dir=none];
transform1 -> union [label=" collectionA, iterableA, iterableB", dir=none];
transform1 -> reverse [label=" collectionA", dir=none];
transform1 -> testTransformedCollection_2 [label=" TRANSFORM_TO_INTEGER", dir=none];
transform1 -> cardinality [label=" iterableA, iterableB", dir=none];
transform1 -> emptyIfNull [label=" collectionA", dir=none];
transform1 -> filter [label=" collectionA, iterableA, iterableB", dir=none];
transform1 -> testIsEmptyWithEmptyCollection [label=" collectionA", dir=none];
transform1 -> getFromObject [label=" collectionA, iterableA, iterableB", dir=none];
transform1 -> addAllForEnumeration [label=" collectionA", dir=none];
transform1 -> testIsEqualCollection [label=" collectionA", dir=none];
transform1 -> getFromList [label=" collectionA, iterableA, iterableB", dir=none];
transform1 -> testDisjunctionAsUnionMinusIntersection [label=" collectionA, iterableA, iterableB", dir=none];
addAllForElements -> forAllButLastDoCollection [label=" collectionA", dir=none];
addAllForElements -> getFromPrimitiveArray [label=" collectionA", dir=none];
addAllForElements -> selectWithOutputCollections [label=" collectionA", dir=none];
addAllForElements -> testPermutations [label=" collectionA", dir=none];
addAllForElements -> testDisjunctionAsSymmetricDifference [label=" collectionA", dir=none];
addAllForElements -> find [label=" collectionA", dir=none];
addAllForElements -> getFromTreeMap [label=" collectionA", dir=none];
addAllForElements -> intersection [label=" collectionA", dir=none];
addAllForElements -> testIsSubCollection2 [label=" collectionA", dir=none];
addAllForElements -> testIsSubCollection [label=" collectionA", dir=none];
addAllForElements -> getEnumeration [label=" collectionA", dir=none];
addAllForElements -> testIsEqualCollectionReturnsFalse [label=" collectionA", dir=none];
addAllForElements -> getPositiveOutOfBounds [label=" collectionA", dir=none];
addAllForElements -> get1 [label=" collectionA", dir=none];
addAllForElements -> testIsSubCollectionOfSelf [label=" collectionA", dir=none];
addAllForElements -> testHashCode [label=" collectionA", dir=none];
addAllForElements -> cardinalityOfNull [label=" collectionA", dir=none];
addAllForElements -> testIsEmptyWithNonEmptyCollection [label=" collectionA", dir=none];
addAllForElements -> getIterator [label=" collectionA", dir=none];
addAllForElements -> filterInverse [label=" collectionA", dir=none];
addAllForElements -> getFromObjectArray [label=" collectionA", dir=none];
addAllForElements -> collect [label=" collectionA", dir=none];
addAllForElements -> testDisjunctionNullColl2 [label=" collectionA", dir=none];
addAllForElements -> getFromIterator [label=" collectionA", dir=none];
addAllForElements -> getFromEnumeration [label=" collectionA", dir=none];
addAllForElements -> testIntersectionNullColl2 [label=" collectionA", dir=none];
addAllForElements -> getFromIterable [label=" collectionA", dir=none];
addAllForElements -> getCardinalityMap [label=" collectionA", dir=none];
addAllForElements -> testMatchesAll [label=" collectionA", dir=none];
addAllForElements -> testRemoveRange [label=" collectionA", dir=none];
addAllForElements -> get [label=" collectionA", dir=none];
addAllForElements -> testIntersectionNullColl1 [label=" collectionA", dir=none];
addAllForElements -> testRemoveCount [label=" collectionA", dir=none];
addAllForElements -> testGetCardinalityMapNull [label=" collectionA", dir=none];
addAllForElements -> intersectionUsesMethodEquals [label=" collectionA", dir=none];
addAllForElements -> testIsProperSubCollection [label=" collectionA", dir=none];
addAllForElements -> collateException1 [label=" collectionA", dir=none];
addAllForElements -> collateException2 [label=" collectionA", dir=none];
addAllForElements -> disjunction [label=" collectionA", dir=none];
addAllForElements -> isEmpty [label=" collectionA", dir=none];
addAllForElements -> forAllDoIterator [label=" collectionA", dir=none];
addAllForElements -> getNegative [label=" collectionA", dir=none];
addAllForElements -> forAllDoCollection [label=" collectionA", dir=none];
addAllForElements -> union [label=" collectionA", dir=none];
addAllForElements -> reverse [label=" collectionA", dir=none];
addAllForElements -> emptyIfNull [label=" collectionA", dir=none];
addAllForElements -> filter [label=" collectionA", dir=none];
addAllForElements -> testIsEmptyWithEmptyCollection [label=" collectionA", dir=none];
addAllForElements -> getFromObject [label=" collectionA", dir=none];
addAllForElements -> addAllForEnumeration [label=" collectionA", dir=none];
addAllForElements -> testIsEqualCollection [label=" collectionA", dir=none];
addAllForElements -> getFromList [label=" collectionA", dir=none];
addAllForElements -> testDisjunctionAsUnionMinusIntersection [label=" collectionA", dir=none];
testDisjunctionNullColl2 -> forAllButLastDoCollection [label=" collectionA", dir=none];
testDisjunctionNullColl2 -> getFromPrimitiveArray [label=" iterableA, collectionA, iterableB", dir=none];
testDisjunctionNullColl2 -> selectWithOutputCollections [label=" collectionA", dir=none];
testDisjunctionNullColl2 -> testPermutations [label=" collectionA", dir=none];
testDisjunctionNullColl2 -> testDisjunctionAsSymmetricDifference [label=" iterableA, collectionA, collectionC2, iterableB, iterableC", dir=none];
testDisjunctionNullColl2 -> find [label=" collectionA", dir=none];
testDisjunctionNullColl2 -> getFromTreeMap [label=" iterableA, collectionA, iterableB", dir=none];
testDisjunctionNullColl2 -> intersection [label=" iterableA, collectionA, collectionC2, iterableB, iterableC", dir=none];
testDisjunctionNullColl2 -> testIsSubCollection2 [label=" collectionA", dir=none];
testDisjunctionNullColl2 -> testIsSubCollection [label=" collectionA", dir=none];
testDisjunctionNullColl2 -> getEnumeration [label=" iterableA, collectionA, iterableB", dir=none];
testDisjunctionNullColl2 -> testIsEqualCollectionReturnsFalse [label=" collectionA", dir=none];
testDisjunctionNullColl2 -> getPositiveOutOfBounds [label=" iterableA, collectionA, iterableB", dir=none];
testDisjunctionNullColl2 -> get1 [label=" iterableA, collectionA, iterableB", dir=none];
testDisjunctionNullColl2 -> testIsSubCollectionOfSelf [label=" collectionA", dir=none];
testDisjunctionNullColl2 -> testHashCode [label=" collectionA", dir=none];
testDisjunctionNullColl2 -> cardinalityOfNull [label=" iterableA, collectionA, iterableB", dir=none];
testDisjunctionNullColl2 -> testIsEmptyWithNonEmptyCollection [label=" collectionA", dir=none];
testDisjunctionNullColl2 -> getIterator [label=" iterableA, collectionA, iterableB", dir=none];
testDisjunctionNullColl2 -> filterInverse [label=" iterableA, collectionA, iterableB", dir=none];
testDisjunctionNullColl2 -> getFromObjectArray [label=" iterableA, collectionA, iterableB", dir=none];
testDisjunctionNullColl2 -> collect [label=" iterableA, collectionA", dir=none];
testDisjunctionNullColl2 -> getFromIterator [label=" iterableA, collectionA, iterableB", dir=none];
testDisjunctionNullColl2 -> getFromEnumeration [label=" iterableA, collectionA, iterableB", dir=none];
testDisjunctionNullColl2 -> testIntersectionNullColl2 [label=" iterableA, collectionA, collectionC2, iterableB, iterableC", dir=none];
testDisjunctionNullColl2 -> getFromIterable [label=" iterableA, collectionA, iterableB", dir=none];
testDisjunctionNullColl2 -> getCardinalityMap [label=" iterableA, collectionA, iterableB", dir=none];
testDisjunctionNullColl2 -> testMatchesAll [label=" collectionA", dir=none];
testDisjunctionNullColl2 -> testRemoveRange [label=" iterableA, collectionA, iterableB", dir=none];
testDisjunctionNullColl2 -> get [label=" iterableA, collectionA, iterableB", dir=none];
testDisjunctionNullColl2 -> testIntersectionNullColl1 [label=" iterableA, collectionA, collectionC2, iterableB, iterableC", dir=none];
testDisjunctionNullColl2 -> testRemoveCount [label=" iterableA, collectionA, iterableB", dir=none];
testDisjunctionNullColl2 -> testGetCardinalityMapNull [label=" iterableA, collectionA, iterableB", dir=none];
testDisjunctionNullColl2 -> intersectionUsesMethodEquals [label=" iterableA, collectionA, collectionC2, iterableB, iterableC", dir=none];
testDisjunctionNullColl2 -> testIsProperSubCollection [label=" iterableA, collectionA, collectionC2, iterableB, iterableC", dir=none];
testDisjunctionNullColl2 -> collateException1 [label=" collectionA", dir=none];
testDisjunctionNullColl2 -> collateException2 [label=" collectionA", dir=none];
testDisjunctionNullColl2 -> disjunction [label=" iterableA, collectionA, collectionC2, iterableB, iterableC", dir=none];
testDisjunctionNullColl2 -> isEmpty [label=" collectionA", dir=none];
testDisjunctionNullColl2 -> forAllDoIterator [label=" collectionA", dir=none];
testDisjunctionNullColl2 -> getNegative [label=" iterableA, collectionA, iterableB", dir=none];
testDisjunctionNullColl2 -> forAllDoCollection [label=" collectionA", dir=none];
testDisjunctionNullColl2 -> union [label=" iterableA, collectionA, collectionC2, iterableB, iterableC", dir=none];
testDisjunctionNullColl2 -> reverse [label=" collectionA", dir=none];
testDisjunctionNullColl2 -> cardinality [label=" iterableA, iterableB", dir=none];
testDisjunctionNullColl2 -> emptyIfNull [label=" collectionA", dir=none];
testDisjunctionNullColl2 -> filter [label=" iterableA, collectionA, iterableB", dir=none];
testDisjunctionNullColl2 -> testIsEmptyWithEmptyCollection [label=" collectionA", dir=none];
testDisjunctionNullColl2 -> getFromObject [label=" iterableA, collectionA, iterableB", dir=none];
testDisjunctionNullColl2 -> addAllForEnumeration [label=" collectionA", dir=none];
testDisjunctionNullColl2 -> testIsEqualCollection [label=" collectionA", dir=none];
testDisjunctionNullColl2 -> getFromList [label=" iterableA, collectionA, iterableB", dir=none];
testDisjunctionNullColl2 -> testDisjunctionAsUnionMinusIntersection [label=" iterableA, collectionA, collectionC2, iterableB, iterableC", dir=none];
getFromIterator -> forAllButLastDoCollection [label=" collectionA", dir=none];
getFromIterator -> getFromPrimitiveArray [label=" iterableA, collectionA, iterableB", dir=none];
getFromIterator -> selectWithOutputCollections [label=" collectionA", dir=none];
getFromIterator -> testPermutations [label=" collectionA", dir=none];
getFromIterator -> testDisjunctionAsSymmetricDifference [label=" iterableA, collectionA, iterableB", dir=none];
getFromIterator -> find [label=" collectionA", dir=none];
getFromIterator -> getFromTreeMap [label=" iterableA, collectionA, iterableB", dir=none];
getFromIterator -> intersection [label=" iterableA, collectionA, iterableB", dir=none];
getFromIterator -> testIsSubCollection2 [label=" collectionA", dir=none];
getFromIterator -> testIsSubCollection [label=" collectionA", dir=none];
getFromIterator -> getEnumeration [label=" iterableA, collectionA, iterableB", dir=none];
getFromIterator -> testIsEqualCollectionReturnsFalse [label=" collectionA", dir=none];
getFromIterator -> getPositiveOutOfBounds [label=" iterableA, collectionA, iterableB", dir=none];
getFromIterator -> get1 [label=" iterableA, collectionA, iterableB", dir=none];
getFromIterator -> testIsSubCollectionOfSelf [label=" collectionA", dir=none];
getFromIterator -> testHashCode [label=" collectionA", dir=none];
getFromIterator -> cardinalityOfNull [label=" iterableA, collectionA, iterableB", dir=none];
getFromIterator -> testIsEmptyWithNonEmptyCollection [label=" collectionA", dir=none];
getFromIterator -> getIterator [label=" iterableA, collectionA, iterableB", dir=none];
getFromIterator -> filterInverse [label=" iterableA, collectionA, iterableB", dir=none];
getFromIterator -> getFromObjectArray [label=" iterableA, collectionA, iterableB", dir=none];
getFromIterator -> collect [label=" iterableA, collectionA", dir=none];
getFromIterator -> getFromEnumeration [label=" iterableA, collectionA, iterableB", dir=none];
getFromIterator -> testIntersectionNullColl2 [label=" iterableA, collectionA, iterableB", dir=none];
getFromIterator -> getFromIterable [label=" iterableA, collectionA, iterableB", dir=none];
getFromIterator -> getCardinalityMap [label=" iterableA, collectionA, iterableB", dir=none];
getFromIterator -> testMatchesAll [label=" collectionA", dir=none];
getFromIterator -> testRemoveRange [label=" iterableA, collectionA, iterableB", dir=none];
getFromIterator -> get [label=" iterableA, collectionA, iterableB", dir=none];
getFromIterator -> testIntersectionNullColl1 [label=" iterableA, collectionA, iterableB", dir=none];
getFromIterator -> testRemoveCount [label=" iterableA, collectionA, iterableB", dir=none];
getFromIterator -> testGetCardinalityMapNull [label=" iterableA, collectionA, iterableB", dir=none];
getFromIterator -> intersectionUsesMethodEquals [label=" iterableA, collectionA, iterableB", dir=none];
getFromIterator -> testIsProperSubCollection [label=" iterableA, collectionA, iterableB", dir=none];
getFromIterator -> collateException1 [label=" collectionA", dir=none];
getFromIterator -> collateException2 [label=" collectionA", dir=none];
getFromIterator -> disjunction [label=" iterableA, collectionA, iterableB", dir=none];
getFromIterator -> isEmpty [label=" collectionA", dir=none];
getFromIterator -> forAllDoIterator [label=" collectionA", dir=none];
getFromIterator -> getNegative [label=" iterableA, collectionA, iterableB", dir=none];
getFromIterator -> forAllDoCollection [label=" collectionA", dir=none];
getFromIterator -> union [label=" iterableA, collectionA, iterableB", dir=none];
getFromIterator -> reverse [label=" collectionA", dir=none];
getFromIterator -> cardinality [label=" iterableA, iterableB", dir=none];
getFromIterator -> emptyIfNull [label=" collectionA", dir=none];
getFromIterator -> filter [label=" iterableA, collectionA, iterableB", dir=none];
getFromIterator -> testIsEmptyWithEmptyCollection [label=" collectionA", dir=none];
getFromIterator -> getFromObject [label=" iterableA, collectionA, iterableB", dir=none];
getFromIterator -> addAllForEnumeration [label=" collectionA", dir=none];
getFromIterator -> testIsEqualCollection [label=" collectionA", dir=none];
getFromIterator -> getFromList [label=" iterableA, collectionA, iterableB", dir=none];
getFromIterator -> testDisjunctionAsUnionMinusIntersection [label=" iterableA, collectionA, iterableB", dir=none];
getFromEnumeration -> forAllButLastDoCollection [label=" collectionA", dir=none];
getFromEnumeration -> getFromPrimitiveArray [label=" collectionA, iterableA, iterableB", dir=none];
getFromEnumeration -> selectWithOutputCollections [label=" collectionA", dir=none];
getFromEnumeration -> testPermutations [label=" collectionA", dir=none];
getFromEnumeration -> testDisjunctionAsSymmetricDifference [label=" collectionA, iterableA, iterableB", dir=none];
getFromEnumeration -> find [label=" collectionA", dir=none];
getFromEnumeration -> getFromTreeMap [label=" collectionA, iterableA, iterableB", dir=none];
getFromEnumeration -> intersection [label=" collectionA, iterableA, iterableB", dir=none];
getFromEnumeration -> testIsSubCollection2 [label=" collectionA", dir=none];
getFromEnumeration -> testIsSubCollection [label=" collectionA", dir=none];
getFromEnumeration -> getEnumeration [label=" collectionA, iterableA, iterableB", dir=none];
getFromEnumeration -> testIsEqualCollectionReturnsFalse [label=" collectionA", dir=none];
getFromEnumeration -> getPositiveOutOfBounds [label=" collectionA, iterableA, iterableB", dir=none];
getFromEnumeration -> get1 [label=" collectionA, iterableA, iterableB", dir=none];
getFromEnumeration -> testIsSubCollectionOfSelf [label=" collectionA", dir=none];
getFromEnumeration -> testHashCode [label=" collectionA", dir=none];
getFromEnumeration -> cardinalityOfNull [label=" collectionA, iterableA, iterableB", dir=none];
getFromEnumeration -> testIsEmptyWithNonEmptyCollection [label=" collectionA", dir=none];
getFromEnumeration -> getIterator [label=" collectionA, iterableA, iterableB", dir=none];
getFromEnumeration -> filterInverse [label=" collectionA, iterableA, iterableB", dir=none];
getFromEnumeration -> getFromObjectArray [label=" collectionA, iterableA, iterableB", dir=none];
getFromEnumeration -> collect [label=" collectionA, iterableA", dir=none];
getFromEnumeration -> testIntersectionNullColl2 [label=" collectionA, iterableA, iterableB", dir=none];
getFromEnumeration -> getFromIterable [label=" collectionA, iterableA, iterableB", dir=none];
getFromEnumeration -> getCardinalityMap [label=" collectionA, iterableA, iterableB", dir=none];
getFromEnumeration -> testMatchesAll [label=" collectionA", dir=none];
getFromEnumeration -> testRemoveRange [label=" collectionA, iterableA, iterableB", dir=none];
getFromEnumeration -> get [label=" collectionA, iterableA, iterableB", dir=none];
getFromEnumeration -> testIntersectionNullColl1 [label=" collectionA, iterableA, iterableB", dir=none];
getFromEnumeration -> testRemoveCount [label=" collectionA, iterableA, iterableB", dir=none];
getFromEnumeration -> testGetCardinalityMapNull [label=" collectionA, iterableA, iterableB", dir=none];
getFromEnumeration -> intersectionUsesMethodEquals [label=" collectionA, iterableA, iterableB", dir=none];
getFromEnumeration -> testIsProperSubCollection [label=" collectionA, iterableA, iterableB", dir=none];
getFromEnumeration -> collateException1 [label=" collectionA", dir=none];
getFromEnumeration -> collateException2 [label=" collectionA", dir=none];
getFromEnumeration -> disjunction [label=" collectionA, iterableA, iterableB", dir=none];
getFromEnumeration -> isEmpty [label=" collectionA", dir=none];
getFromEnumeration -> forAllDoIterator [label=" collectionA", dir=none];
getFromEnumeration -> getNegative [label=" collectionA, iterableA, iterableB", dir=none];
getFromEnumeration -> forAllDoCollection [label=" collectionA", dir=none];
getFromEnumeration -> union [label=" collectionA, iterableA, iterableB", dir=none];
getFromEnumeration -> reverse [label=" collectionA", dir=none];
getFromEnumeration -> cardinality [label=" iterableA, iterableB", dir=none];
getFromEnumeration -> emptyIfNull [label=" collectionA", dir=none];
getFromEnumeration -> filter [label=" collectionA, iterableA, iterableB", dir=none];
getFromEnumeration -> testIsEmptyWithEmptyCollection [label=" collectionA", dir=none];
getFromEnumeration -> getFromObject [label=" collectionA, iterableA, iterableB", dir=none];
getFromEnumeration -> addAllForEnumeration [label=" collectionA", dir=none];
getFromEnumeration -> testIsEqualCollection [label=" collectionA", dir=none];
getFromEnumeration -> getFromList [label=" collectionA, iterableA, iterableB", dir=none];
getFromEnumeration -> testDisjunctionAsUnionMinusIntersection [label=" collectionA, iterableA, iterableB", dir=none];
testIntersectionNullColl2 -> forAllButLastDoCollection [label=" collectionA", dir=none];
testIntersectionNullColl2 -> getFromPrimitiveArray [label=" iterableA, collectionA, iterableB", dir=none];
testIntersectionNullColl2 -> selectWithOutputCollections [label=" collectionA", dir=none];
testIntersectionNullColl2 -> testPermutations [label=" collectionA", dir=none];
testIntersectionNullColl2 -> testDisjunctionAsSymmetricDifference [label=" iterableA, collectionA, collectionC2, iterableB, iterableC", dir=none];
testIntersectionNullColl2 -> find [label=" collectionA", dir=none];
testIntersectionNullColl2 -> getFromTreeMap [label=" iterableA, collectionA, iterableB", dir=none];
testIntersectionNullColl2 -> intersection [label=" iterableA, collectionA, collectionC2, iterableB, iterableC", dir=none];
testIntersectionNullColl2 -> testIsSubCollection2 [label=" collectionA", dir=none];
testIntersectionNullColl2 -> testIsSubCollection [label=" collectionA", dir=none];
testIntersectionNullColl2 -> getEnumeration [label=" iterableA, collectionA, iterableB", dir=none];
testIntersectionNullColl2 -> testIsEqualCollectionReturnsFalse [label=" collectionA", dir=none];
testIntersectionNullColl2 -> getPositiveOutOfBounds [label=" iterableA, collectionA, iterableB", dir=none];
testIntersectionNullColl2 -> get1 [label=" iterableA, collectionA, iterableB", dir=none];
testIntersectionNullColl2 -> testIsSubCollectionOfSelf [label=" collectionA", dir=none];
testIntersectionNullColl2 -> testHashCode [label=" collectionA", dir=none];
testIntersectionNullColl2 -> cardinalityOfNull [label=" iterableA, collectionA, iterableB", dir=none];
testIntersectionNullColl2 -> testIsEmptyWithNonEmptyCollection [label=" collectionA", dir=none];
testIntersectionNullColl2 -> getIterator [label=" iterableA, collectionA, iterableB", dir=none];
testIntersectionNullColl2 -> filterInverse [label=" iterableA, collectionA, iterableB", dir=none];
testIntersectionNullColl2 -> getFromObjectArray [label=" iterableA, collectionA, iterableB", dir=none];
testIntersectionNullColl2 -> collect [label=" iterableA, collectionA", dir=none];
testIntersectionNullColl2 -> getFromIterable [label=" iterableA, collectionA, iterableB", dir=none];
testIntersectionNullColl2 -> getCardinalityMap [label=" iterableA, collectionA, iterableB", dir=none];
testIntersectionNullColl2 -> testMatchesAll [label=" collectionA", dir=none];
testIntersectionNullColl2 -> testRemoveRange [label=" iterableA, collectionA, iterableB", dir=none];
testIntersectionNullColl2 -> get [label=" iterableA, collectionA, iterableB", dir=none];
testIntersectionNullColl2 -> testIntersectionNullColl1 [label=" iterableA, collectionA, collectionC2, iterableB, iterableC", dir=none];
testIntersectionNullColl2 -> testRemoveCount [label=" iterableA, collectionA, iterableB", dir=none];
testIntersectionNullColl2 -> testGetCardinalityMapNull [label=" iterableA, collectionA, iterableB", dir=none];
testIntersectionNullColl2 -> intersectionUsesMethodEquals [label=" iterableA, collectionA, collectionC2, iterableB, iterableC", dir=none];
testIntersectionNullColl2 -> testIsProperSubCollection [label=" iterableA, collectionA, collectionC2, iterableB, iterableC", dir=none];
testIntersectionNullColl2 -> collateException1 [label=" collectionA", dir=none];
testIntersectionNullColl2 -> collateException2 [label=" collectionA", dir=none];
testIntersectionNullColl2 -> disjunction [label=" iterableA, collectionA, collectionC2, iterableB, iterableC", dir=none];
testIntersectionNullColl2 -> isEmpty [label=" collectionA", dir=none];
testIntersectionNullColl2 -> forAllDoIterator [label=" collectionA", dir=none];
testIntersectionNullColl2 -> getNegative [label=" iterableA, collectionA, iterableB", dir=none];
testIntersectionNullColl2 -> forAllDoCollection [label=" collectionA", dir=none];
testIntersectionNullColl2 -> union [label=" iterableA, collectionA, collectionC2, iterableB, iterableC", dir=none];
testIntersectionNullColl2 -> reverse [label=" collectionA", dir=none];
testIntersectionNullColl2 -> cardinality [label=" iterableA, iterableB", dir=none];
testIntersectionNullColl2 -> emptyIfNull [label=" collectionA", dir=none];
testIntersectionNullColl2 -> filter [label=" iterableA, collectionA, iterableB", dir=none];
testIntersectionNullColl2 -> testIsEmptyWithEmptyCollection [label=" collectionA", dir=none];
testIntersectionNullColl2 -> getFromObject [label=" iterableA, collectionA, iterableB", dir=none];
testIntersectionNullColl2 -> addAllForEnumeration [label=" collectionA", dir=none];
testIntersectionNullColl2 -> testIsEqualCollection [label=" collectionA", dir=none];
testIntersectionNullColl2 -> getFromList [label=" iterableA, collectionA, iterableB", dir=none];
testIntersectionNullColl2 -> testDisjunctionAsUnionMinusIntersection [label=" iterableA, collectionA, collectionC2, iterableB, iterableC", dir=none];
getFromIterable -> forAllButLastDoCollection [label=" collectionA", dir=none];
getFromIterable -> getFromPrimitiveArray [label=" collectionA, iterableA, iterableB", dir=none];
getFromIterable -> selectWithOutputCollections [label=" collectionA", dir=none];
getFromIterable -> testPermutations [label=" collectionA", dir=none];
getFromIterable -> testDisjunctionAsSymmetricDifference [label=" collectionA, iterableA, iterableB", dir=none];
getFromIterable -> find [label=" collectionA", dir=none];
getFromIterable -> getFromTreeMap [label=" collectionA, iterableA, iterableB", dir=none];
getFromIterable -> intersection [label=" collectionA, iterableA, iterableB", dir=none];
getFromIterable -> testIsSubCollection2 [label=" collectionA", dir=none];
getFromIterable -> testIsSubCollection [label=" collectionA", dir=none];
getFromIterable -> getEnumeration [label=" collectionA, iterableA, iterableB", dir=none];
getFromIterable -> testIsEqualCollectionReturnsFalse [label=" collectionA", dir=none];
getFromIterable -> getPositiveOutOfBounds [label=" collectionA, iterableA, iterableB", dir=none];
getFromIterable -> get1 [label=" collectionA, iterableA, iterableB", dir=none];
getFromIterable -> testIsSubCollectionOfSelf [label=" collectionA", dir=none];
getFromIterable -> testHashCode [label=" collectionA", dir=none];
getFromIterable -> cardinalityOfNull [label=" collectionA, iterableA, iterableB", dir=none];
getFromIterable -> testIsEmptyWithNonEmptyCollection [label=" collectionA", dir=none];
getFromIterable -> getIterator [label=" collectionA, iterableA, iterableB", dir=none];
getFromIterable -> filterInverse [label=" collectionA, iterableA, iterableB", dir=none];
getFromIterable -> getFromObjectArray [label=" collectionA, iterableA, iterableB", dir=none];
getFromIterable -> collect [label=" collectionA, iterableA", dir=none];
getFromIterable -> getCardinalityMap [label=" collectionA, iterableA, iterableB", dir=none];
getFromIterable -> testMatchesAll [label=" collectionA", dir=none];
getFromIterable -> testRemoveRange [label=" collectionA, iterableA, iterableB", dir=none];
getFromIterable -> get [label=" collectionA, iterableA, iterableB", dir=none];
getFromIterable -> testIntersectionNullColl1 [label=" collectionA, iterableA, iterableB", dir=none];
getFromIterable -> testRemoveCount [label=" collectionA, iterableA, iterableB", dir=none];
getFromIterable -> testGetCardinalityMapNull [label=" collectionA, iterableA, iterableB", dir=none];
getFromIterable -> intersectionUsesMethodEquals [label=" collectionA, iterableA, iterableB", dir=none];
getFromIterable -> testIsProperSubCollection [label=" collectionA, iterableA, iterableB", dir=none];
getFromIterable -> collateException1 [label=" collectionA", dir=none];
getFromIterable -> collateException2 [label=" collectionA", dir=none];
getFromIterable -> disjunction [label=" collectionA, iterableA, iterableB", dir=none];
getFromIterable -> isEmpty [label=" collectionA", dir=none];
getFromIterable -> forAllDoIterator [label=" collectionA", dir=none];
getFromIterable -> getNegative [label=" collectionA, iterableA, iterableB", dir=none];
getFromIterable -> forAllDoCollection [label=" collectionA", dir=none];
getFromIterable -> union [label=" collectionA, iterableA, iterableB", dir=none];
getFromIterable -> reverse [label=" collectionA", dir=none];
getFromIterable -> cardinality [label=" iterableA, iterableB", dir=none];
getFromIterable -> emptyIfNull [label=" collectionA", dir=none];
getFromIterable -> filter [label=" collectionA, iterableA, iterableB", dir=none];
getFromIterable -> testIsEmptyWithEmptyCollection [label=" collectionA", dir=none];
getFromIterable -> getFromObject [label=" collectionA, iterableA, iterableB", dir=none];
getFromIterable -> addAllForEnumeration [label=" collectionA", dir=none];
getFromIterable -> testIsEqualCollection [label=" collectionA", dir=none];
getFromIterable -> getFromList [label=" collectionA, iterableA, iterableB", dir=none];
getFromIterable -> testDisjunctionAsUnionMinusIntersection [label=" collectionA, iterableA, iterableB", dir=none];
getCardinalityMap -> addAllForEnumeration [label=" collectionA", dir=none];
getCardinalityMap -> disjunction [label=" iterableA, collectionA, iterableB", dir=none];
getCardinalityMap -> isEmpty [label=" collectionA", dir=none];
getCardinalityMap -> testGetCardinalityMapNull [label=" iterableA, collectionA, iterableB", dir=none];
getCardinalityMap -> testDisjunctionAsUnionMinusIntersection [label=" iterableA, collectionA, iterableB", dir=none];
getCardinalityMap -> cardinality [label=" iterableA, iterableB", dir=none];
getCardinalityMap -> intersectionUsesMethodEquals [label=" iterableA, collectionA, iterableB", dir=none];
testMatchesAll -> forAllButLastDoCollection [label=" collectionA", dir=none];
testMatchesAll -> getFromPrimitiveArray [label=" collectionA", dir=none];
testMatchesAll -> selectWithOutputCollections [label=" collectionA", dir=none];
testMatchesAll -> testPermutations [label=" collectionA", dir=none];
testMatchesAll -> testDisjunctionAsSymmetricDifference [label=" collectionA", dir=none];
testMatchesAll -> getCardinalityMap [label=" collectionA", dir=none];
testMatchesAll -> testRemoveRange [label=" collectionA", dir=none];
testMatchesAll -> find [label=" collectionA", dir=none];
testMatchesAll -> getFromTreeMap [label=" collectionA", dir=none];
testMatchesAll -> get [label=" collectionA", dir=none];
testMatchesAll -> testIntersectionNullColl1 [label=" collectionA", dir=none];
testMatchesAll -> intersection [label=" collectionA", dir=none];
testMatchesAll -> testRemoveCount [label=" collectionA", dir=none];
testMatchesAll -> testGetCardinalityMapNull [label=" collectionA", dir=none];
testMatchesAll -> testIsSubCollection2 [label=" collectionA", dir=none];
testMatchesAll -> testIsSubCollection [label=" collectionA", dir=none];
testMatchesAll -> intersectionUsesMethodEquals [label=" collectionA", dir=none];
testMatchesAll -> getEnumeration [label=" collectionA", dir=none];
testMatchesAll -> testIsEqualCollectionReturnsFalse [label=" collectionA", dir=none];
testMatchesAll -> testIsProperSubCollection [label=" collectionA", dir=none];
testMatchesAll -> collateException1 [label=" collectionA", dir=none];
testMatchesAll -> collateException2 [label=" collectionA", dir=none];
testMatchesAll -> getPositiveOutOfBounds [label=" collectionA", dir=none];
testMatchesAll -> disjunction [label=" collectionA", dir=none];
testMatchesAll -> isEmpty [label=" collectionA", dir=none];
testMatchesAll -> forAllDoIterator [label=" collectionA", dir=none];
testMatchesAll -> getNegative [label=" collectionA", dir=none];
testMatchesAll -> forAllDoCollection [label=" collectionA", dir=none];
testMatchesAll -> union [label=" collectionA", dir=none];
testMatchesAll -> get1 [label=" collectionA", dir=none];
testMatchesAll -> testIsSubCollectionOfSelf [label=" collectionA", dir=none];
testMatchesAll -> reverse [label=" collectionA", dir=none];
testMatchesAll -> testHashCode [label=" collectionA", dir=none];
testMatchesAll -> cardinalityOfNull [label=" collectionA", dir=none];
testMatchesAll -> emptyIfNull [label=" collectionA", dir=none];
testMatchesAll -> testIsEmptyWithNonEmptyCollection [label=" collectionA", dir=none];
testMatchesAll -> filter [label=" collectionA", dir=none];
testMatchesAll -> testIsEmptyWithEmptyCollection [label=" collectionA", dir=none];
testMatchesAll -> getIterator [label=" collectionA", dir=none];
testMatchesAll -> getFromObject [label=" collectionA", dir=none];
testMatchesAll -> addAllForEnumeration [label=" collectionA", dir=none];
testMatchesAll -> testIsEqualCollection [label=" collectionA", dir=none];
testMatchesAll -> getFromList [label=" collectionA", dir=none];
testMatchesAll -> filterInverse [label=" collectionA", dir=none];
testMatchesAll -> getFromObjectArray [label=" collectionA", dir=none];
testMatchesAll -> collect [label=" collectionA", dir=none];
testMatchesAll -> testDisjunctionAsUnionMinusIntersection [label=" collectionA", dir=none];
testRemoveRange -> forAllButLastDoCollection [label=" collectionA", dir=none];
testRemoveRange -> getFromPrimitiveArray [label=" collectionA, iterableA, iterableB", dir=none];
testRemoveRange -> selectWithOutputCollections [label=" collectionA", dir=none];
testRemoveRange -> testPermutations [label=" collectionA", dir=none];
testRemoveRange -> testDisjunctionAsSymmetricDifference [label=" collectionA, iterableA, iterableB", dir=none];
testRemoveRange -> getCardinalityMap [label=" collectionA, iterableA, iterableB", dir=none];
testRemoveRange -> find [label=" collectionA", dir=none];
testRemoveRange -> getFromTreeMap [label=" collectionA, iterableA, iterableB", dir=none];
testRemoveRange -> get [label=" collectionA, iterableA, iterableB", dir=none];
testRemoveRange -> testIntersectionNullColl1 [label=" collectionA, iterableA, iterableB", dir=none];
testRemoveRange -> intersection [label=" collectionA, iterableA, iterableB", dir=none];
testRemoveRange -> testRemoveCount [label=" collectionA, iterableA, iterableB", dir=none];
testRemoveRange -> testGetCardinalityMapNull [label=" collectionA, iterableA, iterableB", dir=none];
testRemoveRange -> testIsSubCollection2 [label=" collectionA", dir=none];
testRemoveRange -> testIsSubCollection [label=" collectionA", dir=none];
testRemoveRange -> intersectionUsesMethodEquals [label=" collectionA, iterableA, iterableB", dir=none];
testRemoveRange -> getEnumeration [label=" collectionA, iterableA, iterableB", dir=none];
testRemoveRange -> testIsEqualCollectionReturnsFalse [label=" collectionA", dir=none];
testRemoveRange -> testIsProperSubCollection [label=" collectionA, iterableA, iterableB", dir=none];
testRemoveRange -> collateException1 [label=" collectionA", dir=none];
testRemoveRange -> collateException2 [label=" collectionA", dir=none];
testRemoveRange -> getPositiveOutOfBounds [label=" collectionA, iterableA, iterableB", dir=none];
testRemoveRange -> disjunction [label=" collectionA, iterableA, iterableB", dir=none];
testRemoveRange -> isEmpty [label=" collectionA", dir=none];
testRemoveRange -> forAllDoIterator [label=" collectionA", dir=none];
testRemoveRange -> getNegative [label=" collectionA, iterableA, iterableB", dir=none];
testRemoveRange -> forAllDoCollection [label=" collectionA", dir=none];
testRemoveRange -> union [label=" collectionA, iterableA, iterableB", dir=none];
testRemoveRange -> get1 [label=" collectionA, iterableA, iterableB", dir=none];
testRemoveRange -> testIsSubCollectionOfSelf [label=" collectionA", dir=none];
testRemoveRange -> reverse [label=" collectionA", dir=none];
testRemoveRange -> testHashCode [label=" collectionA", dir=none];
testRemoveRange -> cardinalityOfNull [label=" collectionA, iterableA, iterableB", dir=none];
testRemoveRange -> cardinality [label=" iterableA, iterableB", dir=none];
testRemoveRange -> emptyIfNull [label=" collectionA", dir=none];
testRemoveRange -> testIsEmptyWithNonEmptyCollection [label=" collectionA", dir=none];
testRemoveRange -> filter [label=" collectionA, iterableA, iterableB", dir=none];
testRemoveRange -> testIsEmptyWithEmptyCollection [label=" collectionA", dir=none];
testRemoveRange -> getIterator [label=" collectionA, iterableA, iterableB", dir=none];
testRemoveRange -> getFromObject [label=" collectionA, iterableA, iterableB", dir=none];
testRemoveRange -> addAllForEnumeration [label=" collectionA", dir=none];
testRemoveRange -> testIsEqualCollection [label=" collectionA", dir=none];
testRemoveRange -> getFromList [label=" collectionA, iterableA, iterableB", dir=none];
testRemoveRange -> filterInverse [label=" collectionA, iterableA, iterableB", dir=none];
testRemoveRange -> getFromObjectArray [label=" collectionA, iterableA, iterableB", dir=none];
testRemoveRange -> collect [label=" collectionA, iterableA", dir=none];
testRemoveRange -> testDisjunctionAsUnionMinusIntersection [label=" collectionA, iterableA, iterableB", dir=none];
get -> forAllButLastDoCollection [label=" collectionA", dir=none];
get -> getFromPrimitiveArray [label=" collectionA, iterableA, iterableB", dir=none];
get -> selectWithOutputCollections [label=" collectionA", dir=none];
get -> testPermutations [label=" collectionA", dir=none];
get -> testDisjunctionAsSymmetricDifference [label=" collectionA, iterableA, iterableB", dir=none];
get -> getCardinalityMap [label=" collectionA, iterableA, iterableB", dir=none];
get -> find [label=" collectionA", dir=none];
get -> getFromTreeMap [label=" collectionA, iterableA, iterableB", dir=none];
get -> testIntersectionNullColl1 [label=" collectionA, iterableA, iterableB", dir=none];
get -> intersection [label=" collectionA, iterableA, iterableB", dir=none];
get -> testRemoveCount [label=" collectionA, iterableA, iterableB", dir=none];
get -> testGetCardinalityMapNull [label=" collectionA, iterableA, iterableB", dir=none];
get -> testIsSubCollection2 [label=" collectionA", dir=none];
get -> testIsSubCollection [label=" collectionA", dir=none];
get -> intersectionUsesMethodEquals [label=" collectionA, iterableA, iterableB", dir=none];
get -> getEnumeration [label=" collectionA, iterableA, iterableB", dir=none];
get -> testIsEqualCollectionReturnsFalse [label=" collectionA", dir=none];
get -> testIsProperSubCollection [label=" collectionA, iterableA, iterableB", dir=none];
get -> collateException1 [label=" collectionA", dir=none];
get -> collateException2 [label=" collectionA", dir=none];
get -> getPositiveOutOfBounds [label=" collectionA, iterableA, iterableB", dir=none];
get -> disjunction [label=" collectionA, iterableA, iterableB", dir=none];
get -> isEmpty [label=" collectionA", dir=none];
get -> forAllDoIterator [label=" collectionA", dir=none];
get -> getNegative [label=" collectionA, iterableA, iterableB", dir=none];
get -> forAllDoCollection [label=" collectionA", dir=none];
get -> union [label=" collectionA, iterableA, iterableB", dir=none];
get -> get1 [label=" collectionA, iterableA, iterableB", dir=none];
get -> testIsSubCollectionOfSelf [label=" collectionA", dir=none];
get -> reverse [label=" collectionA", dir=none];
get -> testHashCode [label=" collectionA", dir=none];
get -> cardinalityOfNull [label=" collectionA, iterableA, iterableB", dir=none];
get -> cardinality [label=" iterableA, iterableB", dir=none];
get -> emptyIfNull [label=" collectionA", dir=none];
get -> testIsEmptyWithNonEmptyCollection [label=" collectionA", dir=none];
get -> filter [label=" collectionA, iterableA, iterableB", dir=none];
get -> testIsEmptyWithEmptyCollection [label=" collectionA", dir=none];
get -> getIterator [label=" collectionA, iterableA, iterableB", dir=none];
get -> getFromObject [label=" collectionA, iterableA, iterableB", dir=none];
get -> addAllForEnumeration [label=" collectionA", dir=none];
get -> testIsEqualCollection [label=" collectionA", dir=none];
get -> getFromList [label=" collectionA, iterableA, iterableB", dir=none];
get -> filterInverse [label=" collectionA, iterableA, iterableB", dir=none];
get -> getFromObjectArray [label=" collectionA, iterableA, iterableB", dir=none];
get -> collect [label=" collectionA, iterableA", dir=none];
get -> testDisjunctionAsUnionMinusIntersection [label=" collectionA, iterableA, iterableB", dir=none];
testIntersectionNullColl1 -> forAllButLastDoCollection [label=" collectionA", dir=none];
testIntersectionNullColl1 -> getFromPrimitiveArray [label=" iterableA, collectionA, iterableB", dir=none];
testIntersectionNullColl1 -> selectWithOutputCollections [label=" collectionA", dir=none];
testIntersectionNullColl1 -> testPermutations [label=" collectionA", dir=none];
testIntersectionNullColl1 -> testDisjunctionAsSymmetricDifference [label=" iterableA, collectionA, collectionC2, iterableB, iterableC", dir=none];
testIntersectionNullColl1 -> getCardinalityMap [label=" iterableA, collectionA, iterableB", dir=none];
testIntersectionNullColl1 -> find [label=" collectionA", dir=none];
testIntersectionNullColl1 -> getFromTreeMap [label=" iterableA, collectionA, iterableB", dir=none];
testIntersectionNullColl1 -> intersection [label=" iterableA, collectionA, collectionC2, iterableB, iterableC", dir=none];
testIntersectionNullColl1 -> testRemoveCount [label=" iterableA, collectionA, iterableB", dir=none];
testIntersectionNullColl1 -> testGetCardinalityMapNull [label=" iterableA, collectionA, iterableB", dir=none];
testIntersectionNullColl1 -> testIsSubCollection2 [label=" collectionA", dir=none];
testIntersectionNullColl1 -> testIsSubCollection [label=" collectionA", dir=none];
testIntersectionNullColl1 -> intersectionUsesMethodEquals [label=" iterableA, collectionA, collectionC2, iterableB, iterableC", dir=none];
testIntersectionNullColl1 -> getEnumeration [label=" iterableA, collectionA, iterableB", dir=none];
testIntersectionNullColl1 -> testIsEqualCollectionReturnsFalse [label=" collectionA", dir=none];
testIntersectionNullColl1 -> testIsProperSubCollection [label=" iterableA, collectionA, collectionC2, iterableB, iterableC", dir=none];
testIntersectionNullColl1 -> collateException1 [label=" collectionA", dir=none];
testIntersectionNullColl1 -> collateException2 [label=" collectionA", dir=none];
testIntersectionNullColl1 -> getPositiveOutOfBounds [label=" iterableA, collectionA, iterableB", dir=none];
testIntersectionNullColl1 -> disjunction [label=" iterableA, collectionA, collectionC2, iterableB, iterableC", dir=none];
testIntersectionNullColl1 -> isEmpty [label=" collectionA", dir=none];
testIntersectionNullColl1 -> forAllDoIterator [label=" collectionA", dir=none];
testIntersectionNullColl1 -> getNegative [label=" iterableA, collectionA, iterableB", dir=none];
testIntersectionNullColl1 -> forAllDoCollection [label=" collectionA", dir=none];
testIntersectionNullColl1 -> union [label=" iterableA, collectionA, collectionC2, iterableB, iterableC", dir=none];
testIntersectionNullColl1 -> get1 [label=" iterableA, collectionA, iterableB", dir=none];
testIntersectionNullColl1 -> testIsSubCollectionOfSelf [label=" collectionA", dir=none];
testIntersectionNullColl1 -> reverse [label=" collectionA", dir=none];
testIntersectionNullColl1 -> testHashCode [label=" collectionA", dir=none];
testIntersectionNullColl1 -> cardinalityOfNull [label=" iterableA, collectionA, iterableB", dir=none];
testIntersectionNullColl1 -> cardinality [label=" iterableA, iterableB", dir=none];
testIntersectionNullColl1 -> emptyIfNull [label=" collectionA", dir=none];
testIntersectionNullColl1 -> testIsEmptyWithNonEmptyCollection [label=" collectionA", dir=none];
testIntersectionNullColl1 -> filter [label=" iterableA, collectionA, iterableB", dir=none];
testIntersectionNullColl1 -> testIsEmptyWithEmptyCollection [label=" collectionA", dir=none];
testIntersectionNullColl1 -> getIterator [label=" iterableA, collectionA, iterableB", dir=none];
testIntersectionNullColl1 -> getFromObject [label=" iterableA, collectionA, iterableB", dir=none];
testIntersectionNullColl1 -> addAllForEnumeration [label=" collectionA", dir=none];
testIntersectionNullColl1 -> testIsEqualCollection [label=" collectionA", dir=none];
testIntersectionNullColl1 -> getFromList [label=" iterableA, collectionA, iterableB", dir=none];
testIntersectionNullColl1 -> filterInverse [label=" iterableA, collectionA, iterableB", dir=none];
testIntersectionNullColl1 -> getFromObjectArray [label=" iterableA, collectionA, iterableB", dir=none];
testIntersectionNullColl1 -> collect [label=" iterableA, collectionA", dir=none];
testIntersectionNullColl1 -> testDisjunctionAsUnionMinusIntersection [label=" iterableA, collectionA, collectionC2, iterableB, iterableC", dir=none];
testRemoveCount -> forAllButLastDoCollection [label=" collectionA", dir=none];
testRemoveCount -> getFromPrimitiveArray [label=" collectionA, iterableA, iterableB", dir=none];
testRemoveCount -> selectWithOutputCollections [label=" collectionA", dir=none];
testRemoveCount -> testPermutations [label=" collectionA", dir=none];
testRemoveCount -> testDisjunctionAsSymmetricDifference [label=" collectionA, iterableA, iterableB", dir=none];
testRemoveCount -> getCardinalityMap [label=" collectionA, iterableA, iterableB", dir=none];
testRemoveCount -> find [label=" collectionA", dir=none];
testRemoveCount -> getFromTreeMap [label=" collectionA, iterableA, iterableB", dir=none];
testRemoveCount -> intersection [label=" collectionA, iterableA, iterableB", dir=none];
testRemoveCount -> testGetCardinalityMapNull [label=" collectionA, iterableA, iterableB", dir=none];
testRemoveCount -> testIsSubCollection2 [label=" collectionA", dir=none];
testRemoveCount -> testIsSubCollection [label=" collectionA", dir=none];
testRemoveCount -> intersectionUsesMethodEquals [label=" collectionA, iterableA, iterableB", dir=none];
testRemoveCount -> getEnumeration [label=" collectionA, iterableA, iterableB", dir=none];
testRemoveCount -> testIsEqualCollectionReturnsFalse [label=" collectionA", dir=none];
testRemoveCount -> testIsProperSubCollection [label=" collectionA, iterableA, iterableB", dir=none];
testRemoveCount -> collateException1 [label=" collectionA", dir=none];
testRemoveCount -> collateException2 [label=" collectionA", dir=none];
testRemoveCount -> getPositiveOutOfBounds [label=" collectionA, iterableA, iterableB", dir=none];
testRemoveCount -> disjunction [label=" collectionA, iterableA, iterableB", dir=none];
testRemoveCount -> isEmpty [label=" collectionA", dir=none];
testRemoveCount -> forAllDoIterator [label=" collectionA", dir=none];
testRemoveCount -> getNegative [label=" collectionA, iterableA, iterableB", dir=none];
testRemoveCount -> forAllDoCollection [label=" collectionA", dir=none];
testRemoveCount -> union [label=" collectionA, iterableA, iterableB", dir=none];
testRemoveCount -> get1 [label=" collectionA, iterableA, iterableB", dir=none];
testRemoveCount -> testIsSubCollectionOfSelf [label=" collectionA", dir=none];
testRemoveCount -> reverse [label=" collectionA", dir=none];
testRemoveCount -> testHashCode [label=" collectionA", dir=none];
testRemoveCount -> cardinalityOfNull [label=" collectionA, iterableA, iterableB", dir=none];
testRemoveCount -> cardinality [label=" iterableA, iterableB", dir=none];
testRemoveCount -> emptyIfNull [label=" collectionA", dir=none];
testRemoveCount -> testIsEmptyWithNonEmptyCollection [label=" collectionA", dir=none];
testRemoveCount -> filter [label=" collectionA, iterableA, iterableB", dir=none];
testRemoveCount -> testIsEmptyWithEmptyCollection [label=" collectionA", dir=none];
testRemoveCount -> getIterator [label=" collectionA, iterableA, iterableB", dir=none];
testRemoveCount -> getFromObject [label=" collectionA, iterableA, iterableB", dir=none];
testRemoveCount -> addAllForEnumeration [label=" collectionA", dir=none];
testRemoveCount -> testIsEqualCollection [label=" collectionA", dir=none];
testRemoveCount -> getFromList [label=" collectionA, iterableA, iterableB", dir=none];
testRemoveCount -> filterInverse [label=" collectionA, iterableA, iterableB", dir=none];
testRemoveCount -> getFromObjectArray [label=" collectionA, iterableA, iterableB", dir=none];
testRemoveCount -> collect [label=" collectionA, iterableA", dir=none];
testRemoveCount -> testDisjunctionAsUnionMinusIntersection [label=" collectionA, iterableA, iterableB", dir=none];
testGetCardinalityMapNull -> addAllForEnumeration [label=" collectionA", dir=none];
testGetCardinalityMapNull -> disjunction [label=" iterableA, collectionA, iterableB", dir=none];
testGetCardinalityMapNull -> isEmpty [label=" collectionA", dir=none];
testGetCardinalityMapNull -> testDisjunctionAsUnionMinusIntersection [label=" iterableA, collectionA, iterableB", dir=none];
testGetCardinalityMapNull -> cardinality [label=" iterableA, iterableB", dir=none];
testGetCardinalityMapNull -> intersectionUsesMethodEquals [label=" iterableA, collectionA, iterableB", dir=none];
intersectionUsesMethodEquals -> addAllForEnumeration [label=" collectionA", dir=none];
intersectionUsesMethodEquals -> disjunction [label=" iterableA, collectionA, collectionC2, iterableB, iterableC", dir=none];
intersectionUsesMethodEquals -> isEmpty [label=" collectionA", dir=none];
intersectionUsesMethodEquals -> testDisjunctionAsUnionMinusIntersection [label=" iterableA, collectionA, collectionC2, iterableB, iterableC", dir=none];
intersectionUsesMethodEquals -> cardinality [label=" iterableA, iterableB", dir=none];
testIsProperSubCollection -> forAllButLastDoCollection [label=" collectionA", dir=none];
testIsProperSubCollection -> getFromPrimitiveArray [label=" collectionA, iterableA, iterableB", dir=none];
testIsProperSubCollection -> selectWithOutputCollections [label=" collectionA", dir=none];
testIsProperSubCollection -> testPermutations [label=" collectionA", dir=none];
testIsProperSubCollection -> testDisjunctionAsSymmetricDifference [label=" collectionA, iterableA, collectionC, collectionC2, iterableB, iterableC", dir=none];
testIsProperSubCollection -> getCardinalityMap [label=" collectionA, iterableA, iterableB", dir=none];
testIsProperSubCollection -> find [label=" collectionA", dir=none];
testIsProperSubCollection -> getFromTreeMap [label=" collectionA, iterableA, iterableB", dir=none];
testIsProperSubCollection -> intersection [label=" collectionA, iterableA, collectionC2, iterableB, iterableC", dir=none];
testIsProperSubCollection -> testGetCardinalityMapNull [label=" collectionA, iterableA, iterableB", dir=none];
testIsProperSubCollection -> testIsSubCollection2 [label=" collectionA", dir=none];
testIsProperSubCollection -> testIsSubCollection [label=" collectionA, collectionC", dir=none];
testIsProperSubCollection -> intersectionUsesMethodEquals [label=" collectionA, iterableA, collectionC2, iterableB, iterableC", dir=none];
testIsProperSubCollection -> getEnumeration [label=" collectionA, iterableA, iterableB", dir=none];
testIsProperSubCollection -> testIsEqualCollectionReturnsFalse [label=" collectionA", dir=none];
testIsProperSubCollection -> collateException1 [label=" collectionA", dir=none];
testIsProperSubCollection -> collateException2 [label=" collectionA, collectionC", dir=none];
testIsProperSubCollection -> getPositiveOutOfBounds [label=" collectionA, iterableA, iterableB", dir=none];
testIsProperSubCollection -> disjunction [label=" collectionA, iterableA, collectionC2, iterableB, iterableC", dir=none];
testIsProperSubCollection -> isEmpty [label=" collectionA", dir=none];
testIsProperSubCollection -> forAllDoIterator [label=" collectionA, collectionC", dir=none];
testIsProperSubCollection -> getNegative [label=" collectionA, iterableA, iterableB", dir=none];
testIsProperSubCollection -> collateException0 [label=" collectionC", dir=none];
testIsProperSubCollection -> forAllDoCollection [label=" collectionA, collectionC", dir=none];
testIsProperSubCollection -> union [label=" collectionA, iterableA, collectionC2, iterableB, iterableC", dir=none];
testIsProperSubCollection -> get1 [label=" collectionA, iterableA, iterableB", dir=none];
testIsProperSubCollection -> testIsSubCollectionOfSelf [label=" collectionA", dir=none];
testIsProperSubCollection -> reverse [label=" collectionA", dir=none];
testIsProperSubCollection -> testHashCode [label=" collectionA", dir=none];
testIsProperSubCollection -> cardinalityOfNull [label=" collectionA, iterableA, iterableB", dir=none];
testIsProperSubCollection -> cardinality [label=" iterableA, iterableB", dir=none];
testIsProperSubCollection -> emptyIfNull [label=" collectionA", dir=none];
testIsProperSubCollection -> testIsEmptyWithNonEmptyCollection [label=" collectionA", dir=none];
testIsProperSubCollection -> filter [label=" collectionA, iterableA, iterableB", dir=none];
testIsProperSubCollection -> testIsEmptyWithEmptyCollection [label=" collectionA", dir=none];
testIsProperSubCollection -> getIterator [label=" collectionA, iterableA, iterableB", dir=none];
testIsProperSubCollection -> getFromObject [label=" collectionA, iterableA, iterableB", dir=none];
testIsProperSubCollection -> addAllForEnumeration [label=" collectionA", dir=none];
testIsProperSubCollection -> testIsEqualCollection [label=" collectionA, collectionC", dir=none];
testIsProperSubCollection -> getFromList [label=" collectionA, iterableA, iterableB", dir=none];
testIsProperSubCollection -> filterInverse [label=" collectionA, iterableA, iterableB", dir=none];
testIsProperSubCollection -> getFromObjectArray [label=" collectionA, iterableA, iterableB", dir=none];
testIsProperSubCollection -> collect [label=" collectionA, iterableA", dir=none];
testIsProperSubCollection -> testDisjunctionAsUnionMinusIntersection [label=" collectionA, iterableA, collectionC, collectionC2, iterableB, iterableC", dir=none];
collateException1 -> forAllButLastDoCollection [label=" collectionA", dir=none];
collateException1 -> getFromPrimitiveArray [label=" collectionA", dir=none];
collateException1 -> selectWithOutputCollections [label=" collectionA", dir=none];
collateException1 -> testPermutations [label=" collectionA", dir=none];
collateException1 -> testDisjunctionAsSymmetricDifference [label=" collectionA", dir=none];
collateException1 -> getCardinalityMap [label=" collectionA", dir=none];
collateException1 -> find [label=" collectionA", dir=none];
collateException1 -> getFromTreeMap [label=" collectionA", dir=none];
collateException1 -> intersection [label=" collectionA", dir=none];
collateException1 -> testGetCardinalityMapNull [label=" collectionA", dir=none];
collateException1 -> testIsSubCollection2 [label=" collectionA", dir=none];
collateException1 -> testIsSubCollection [label=" collectionA", dir=none];
collateException1 -> intersectionUsesMethodEquals [label=" collectionA", dir=none];
collateException1 -> getEnumeration [label=" collectionA", dir=none];
collateException1 -> testIsEqualCollectionReturnsFalse [label=" collectionA", dir=none];
collateException1 -> collateException2 [label=" collectionA", dir=none];
collateException1 -> getPositiveOutOfBounds [label=" collectionA", dir=none];
collateException1 -> disjunction [label=" collectionA", dir=none];
collateException1 -> isEmpty [label=" collectionA", dir=none];
collateException1 -> forAllDoIterator [label=" collectionA", dir=none];
collateException1 -> getNegative [label=" collectionA", dir=none];
collateException1 -> forAllDoCollection [label=" collectionA", dir=none];
collateException1 -> union [label=" collectionA", dir=none];
collateException1 -> get1 [label=" collectionA", dir=none];
collateException1 -> testIsSubCollectionOfSelf [label=" collectionA", dir=none];
collateException1 -> reverse [label=" collectionA", dir=none];
collateException1 -> testHashCode [label=" collectionA", dir=none];
collateException1 -> cardinalityOfNull [label=" collectionA", dir=none];
collateException1 -> emptyIfNull [label=" collectionA", dir=none];
collateException1 -> testIsEmptyWithNonEmptyCollection [label=" collectionA", dir=none];
collateException1 -> filter [label=" collectionA", dir=none];
collateException1 -> testIsEmptyWithEmptyCollection [label=" collectionA", dir=none];
collateException1 -> getIterator [label=" collectionA", dir=none];
collateException1 -> getFromObject [label=" collectionA", dir=none];
collateException1 -> addAllForEnumeration [label=" collectionA", dir=none];
collateException1 -> testIsEqualCollection [label=" collectionA", dir=none];
collateException1 -> getFromList [label=" collectionA", dir=none];
collateException1 -> filterInverse [label=" collectionA", dir=none];
collateException1 -> getFromObjectArray [label=" collectionA", dir=none];
collateException1 -> collect [label=" collectionA", dir=none];
collateException1 -> testDisjunctionAsUnionMinusIntersection [label=" collectionA", dir=none];
collateException2 -> forAllButLastDoCollection [label=" collectionA", dir=none];
collateException2 -> getFromPrimitiveArray [label=" collectionA", dir=none];
collateException2 -> selectWithOutputCollections [label=" collectionA", dir=none];
collateException2 -> testPermutations [label=" collectionA", dir=none];
collateException2 -> testDisjunctionAsSymmetricDifference [label=" collectionA, collectionC", dir=none];
collateException2 -> getCardinalityMap [label=" collectionA", dir=none];
collateException2 -> find [label=" collectionA", dir=none];
collateException2 -> getFromTreeMap [label=" collectionA", dir=none];
collateException2 -> intersection [label=" collectionA", dir=none];
collateException2 -> testGetCardinalityMapNull [label=" collectionA", dir=none];
collateException2 -> testIsSubCollection2 [label=" collectionA", dir=none];
collateException2 -> testIsSubCollection [label=" collectionA, collectionC", dir=none];
collateException2 -> intersectionUsesMethodEquals [label=" collectionA", dir=none];
collateException2 -> getEnumeration [label=" collectionA", dir=none];
collateException2 -> testIsEqualCollectionReturnsFalse [label=" collectionA", dir=none];
collateException2 -> getPositiveOutOfBounds [label=" collectionA", dir=none];
collateException2 -> disjunction [label=" collectionA", dir=none];
collateException2 -> isEmpty [label=" collectionA", dir=none];
collateException2 -> forAllDoIterator [label=" collectionA, collectionC", dir=none];
collateException2 -> getNegative [label=" collectionA", dir=none];
collateException2 -> collateException0 [label=" collectionC", dir=none];
collateException2 -> forAllDoCollection [label=" collectionA, collectionC", dir=none];
collateException2 -> union [label=" collectionA", dir=none];
collateException2 -> get1 [label=" collectionA", dir=none];
collateException2 -> testIsSubCollectionOfSelf [label=" collectionA", dir=none];
collateException2 -> reverse [label=" collectionA", dir=none];
collateException2 -> testHashCode [label=" collectionA", dir=none];
collateException2 -> cardinalityOfNull [label=" collectionA", dir=none];
collateException2 -> emptyIfNull [label=" collectionA", dir=none];
collateException2 -> testIsEmptyWithNonEmptyCollection [label=" collectionA", dir=none];
collateException2 -> filter [label=" collectionA", dir=none];
collateException2 -> testIsEmptyWithEmptyCollection [label=" collectionA", dir=none];
collateException2 -> getIterator [label=" collectionA", dir=none];
collateException2 -> getFromObject [label=" collectionA", dir=none];
collateException2 -> addAllForEnumeration [label=" collectionA", dir=none];
collateException2 -> testIsEqualCollection [label=" collectionA, collectionC", dir=none];
collateException2 -> getFromList [label=" collectionA", dir=none];
collateException2 -> filterInverse [label=" collectionA", dir=none];
collateException2 -> getFromObjectArray [label=" collectionA", dir=none];
collateException2 -> collect [label=" collectionA", dir=none];
collateException2 -> testDisjunctionAsUnionMinusIntersection [label=" collectionA, collectionC", dir=none];
disjunction -> addAllForEnumeration [label=" collectionA", dir=none];
disjunction -> isEmpty [label=" collectionA", dir=none];
disjunction -> testDisjunctionAsUnionMinusIntersection [label=" iterableA, collectionA, collectionC2, iterableB, iterableC", dir=none];
disjunction -> cardinality [label=" iterableA, iterableB", dir=none];
isEmpty -> addAllForEnumeration [label=" collectionA", dir=none];
isEmpty -> testDisjunctionAsUnionMinusIntersection [label=" collectionA", dir=none];
forAllDoIterator -> forAllButLastDoCollection [label=" collectionA", dir=none];
forAllDoIterator -> getFromPrimitiveArray [label=" collectionA", dir=none];
forAllDoIterator -> selectWithOutputCollections [label=" collectionA", dir=none];
forAllDoIterator -> testPermutations [label=" collectionA", dir=none];
forAllDoIterator -> testDisjunctionAsSymmetricDifference [label=" collectionA, collectionC", dir=none];
forAllDoIterator -> getCardinalityMap [label=" collectionA", dir=none];
forAllDoIterator -> find [label=" collectionA", dir=none];
forAllDoIterator -> getFromTreeMap [label=" collectionA", dir=none];
forAllDoIterator -> intersection [label=" collectionA", dir=none];
forAllDoIterator -> testGetCardinalityMapNull [label=" collectionA", dir=none];
forAllDoIterator -> testIsSubCollection2 [label=" collectionA", dir=none];
forAllDoIterator -> testIsSubCollection [label=" collectionA, collectionC", dir=none];
forAllDoIterator -> intersectionUsesMethodEquals [label=" collectionA", dir=none];
forAllDoIterator -> getEnumeration [label=" collectionA", dir=none];
forAllDoIterator -> testIsEqualCollectionReturnsFalse [label=" collectionA", dir=none];
forAllDoIterator -> getPositiveOutOfBounds [label=" collectionA", dir=none];
forAllDoIterator -> disjunction [label=" collectionA", dir=none];
forAllDoIterator -> isEmpty [label=" collectionA", dir=none];
forAllDoIterator -> getNegative [label=" collectionA", dir=none];
forAllDoIterator -> collateException0 [label=" collectionC", dir=none];
forAllDoIterator -> forAllDoCollection [label=" collectionA, collectionC", dir=none];
forAllDoIterator -> union [label=" collectionA", dir=none];
forAllDoIterator -> get1 [label=" collectionA", dir=none];
forAllDoIterator -> testIsSubCollectionOfSelf [label=" collectionA", dir=none];
forAllDoIterator -> reverse [label=" collectionA", dir=none];
forAllDoIterator -> testHashCode [label=" collectionA", dir=none];
forAllDoIterator -> cardinalityOfNull [label=" collectionA", dir=none];
forAllDoIterator -> emptyIfNull [label=" collectionA", dir=none];
forAllDoIterator -> testIsEmptyWithNonEmptyCollection [label=" collectionA", dir=none];
forAllDoIterator -> filter [label=" collectionA", dir=none];
forAllDoIterator -> testIsEmptyWithEmptyCollection [label=" collectionA", dir=none];
forAllDoIterator -> getIterator [label=" collectionA", dir=none];
forAllDoIterator -> getFromObject [label=" collectionA", dir=none];
forAllDoIterator -> addAllForEnumeration [label=" collectionA", dir=none];
forAllDoIterator -> testIsEqualCollection [label=" collectionA, collectionC", dir=none];
forAllDoIterator -> getFromList [label=" collectionA", dir=none];
forAllDoIterator -> filterInverse [label=" collectionA", dir=none];
forAllDoIterator -> getFromObjectArray [label=" collectionA", dir=none];
forAllDoIterator -> collect [label=" collectionA", dir=none];
forAllDoIterator -> testDisjunctionAsUnionMinusIntersection [label=" collectionA, collectionC", dir=none];
getNegative -> forAllButLastDoCollection [label=" collectionA", dir=none];
getNegative -> getFromPrimitiveArray [label=" collectionA, iterableA, iterableB", dir=none];
getNegative -> selectWithOutputCollections [label=" collectionA", dir=none];
getNegative -> testPermutations [label=" collectionA", dir=none];
getNegative -> testDisjunctionAsSymmetricDifference [label=" collectionA, iterableA, iterableB", dir=none];
getNegative -> getCardinalityMap [label=" collectionA, iterableA, iterableB", dir=none];
getNegative -> find [label=" collectionA", dir=none];
getNegative -> getFromTreeMap [label=" collectionA, iterableA, iterableB", dir=none];
getNegative -> intersection [label=" collectionA, iterableA, iterableB", dir=none];
getNegative -> testGetCardinalityMapNull [label=" collectionA, iterableA, iterableB", dir=none];
getNegative -> testIsSubCollection2 [label=" collectionA", dir=none];
getNegative -> testIsSubCollection [label=" collectionA", dir=none];
getNegative -> intersectionUsesMethodEquals [label=" collectionA, iterableA, iterableB", dir=none];
getNegative -> getEnumeration [label=" collectionA, iterableA, iterableB", dir=none];
getNegative -> testIsEqualCollectionReturnsFalse [label=" collectionA", dir=none];
getNegative -> getPositiveOutOfBounds [label=" collectionA, iterableA, iterableB", dir=none];
getNegative -> disjunction [label=" collectionA, iterableA, iterableB", dir=none];
getNegative -> isEmpty [label=" collectionA", dir=none];
getNegative -> forAllDoCollection [label=" collectionA", dir=none];
getNegative -> union [label=" collectionA, iterableA, iterableB", dir=none];
getNegative -> get1 [label=" collectionA, iterableA, iterableB", dir=none];
getNegative -> testIsSubCollectionOfSelf [label=" collectionA", dir=none];
getNegative -> reverse [label=" collectionA", dir=none];
getNegative -> testHashCode [label=" collectionA", dir=none];
getNegative -> cardinalityOfNull [label=" collectionA, iterableA, iterableB", dir=none];
getNegative -> cardinality [label=" iterableA, iterableB", dir=none];
getNegative -> emptyIfNull [label=" collectionA", dir=none];
getNegative -> testIsEmptyWithNonEmptyCollection [label=" collectionA", dir=none];
getNegative -> filter [label=" collectionA, iterableA, iterableB", dir=none];
getNegative -> testIsEmptyWithEmptyCollection [label=" collectionA", dir=none];
getNegative -> getIterator [label=" collectionA, iterableA, iterableB", dir=none];
getNegative -> getFromObject [label=" collectionA, iterableA, iterableB", dir=none];
getNegative -> addAllForEnumeration [label=" collectionA", dir=none];
getNegative -> testIsEqualCollection [label=" collectionA", dir=none];
getNegative -> getFromList [label=" collectionA, iterableA, iterableB", dir=none];
getNegative -> filterInverse [label=" collectionA, iterableA, iterableB", dir=none];
getNegative -> getFromObjectArray [label=" collectionA, iterableA, iterableB", dir=none];
getNegative -> collect [label=" collectionA, iterableA", dir=none];
getNegative -> testDisjunctionAsUnionMinusIntersection [label=" collectionA, iterableA, iterableB", dir=none];
collateException0 -> testIsEqualCollection [label=" collectionC", dir=none];
collateException0 -> forAllDoCollection [label=" collectionC", dir=none];
collateException0 -> testDisjunctionAsSymmetricDifference [label=" collectionC", dir=none];
collateException0 -> testDisjunctionAsUnionMinusIntersection [label=" collectionC", dir=none];
collateException0 -> testIsSubCollection [label=" collectionC", dir=none];
forAllDoCollection -> forAllButLastDoCollection [label=" collectionA", dir=none];
forAllDoCollection -> getFromPrimitiveArray [label=" collectionA", dir=none];
forAllDoCollection -> selectWithOutputCollections [label=" collectionA", dir=none];
forAllDoCollection -> testPermutations [label=" collectionA", dir=none];
forAllDoCollection -> testDisjunctionAsSymmetricDifference [label=" collectionA, collectionC", dir=none];
forAllDoCollection -> getCardinalityMap [label=" collectionA", dir=none];
forAllDoCollection -> find [label=" collectionA", dir=none];
forAllDoCollection -> getFromTreeMap [label=" collectionA", dir=none];
forAllDoCollection -> intersection [label=" collectionA", dir=none];
forAllDoCollection -> testGetCardinalityMapNull [label=" collectionA", dir=none];
forAllDoCollection -> testIsSubCollection2 [label=" collectionA", dir=none];
forAllDoCollection -> testIsSubCollection [label=" collectionA, collectionC", dir=none];
forAllDoCollection -> intersectionUsesMethodEquals [label=" collectionA", dir=none];
forAllDoCollection -> getEnumeration [label=" collectionA", dir=none];
forAllDoCollection -> testIsEqualCollectionReturnsFalse [label=" collectionA", dir=none];
forAllDoCollection -> getPositiveOutOfBounds [label=" collectionA", dir=none];
forAllDoCollection -> disjunction [label=" collectionA", dir=none];
forAllDoCollection -> isEmpty [label=" collectionA", dir=none];
forAllDoCollection -> union [label=" collectionA", dir=none];
forAllDoCollection -> get1 [label=" collectionA", dir=none];
forAllDoCollection -> testIsSubCollectionOfSelf [label=" collectionA", dir=none];
forAllDoCollection -> reverse [label=" collectionA", dir=none];
forAllDoCollection -> testHashCode [label=" collectionA", dir=none];
forAllDoCollection -> cardinalityOfNull [label=" collectionA", dir=none];
forAllDoCollection -> emptyIfNull [label=" collectionA", dir=none];
forAllDoCollection -> testIsEmptyWithNonEmptyCollection [label=" collectionA", dir=none];
forAllDoCollection -> filter [label=" collectionA", dir=none];
forAllDoCollection -> testIsEmptyWithEmptyCollection [label=" collectionA", dir=none];
forAllDoCollection -> getIterator [label=" collectionA", dir=none];
forAllDoCollection -> getFromObject [label=" collectionA", dir=none];
forAllDoCollection -> addAllForEnumeration [label=" collectionA", dir=none];
forAllDoCollection -> testIsEqualCollection [label=" collectionA, collectionC", dir=none];
forAllDoCollection -> getFromList [label=" collectionA", dir=none];
forAllDoCollection -> filterInverse [label=" collectionA", dir=none];
forAllDoCollection -> getFromObjectArray [label=" collectionA", dir=none];
forAllDoCollection -> collect [label=" collectionA", dir=none];
forAllDoCollection -> testDisjunctionAsUnionMinusIntersection [label=" collectionA, collectionC", dir=none];
union -> forAllButLastDoCollection [label=" collectionA", dir=none];
union -> getFromPrimitiveArray [label=" iterableA, collectionA, iterableB", dir=none];
union -> selectWithOutputCollections [label=" collectionA", dir=none];
union -> testPermutations [label=" collectionA", dir=none];
union -> testDisjunctionAsSymmetricDifference [label=" iterableA, collectionA, collectionC2, iterableB, iterableC", dir=none];
union -> getCardinalityMap [label=" iterableA, collectionA, iterableB", dir=none];
union -> find [label=" collectionA", dir=none];
union -> getFromTreeMap [label=" iterableA, collectionA, iterableB", dir=none];
union -> intersection [label=" iterableA, collectionA, collectionC2, iterableB, iterableC", dir=none];
union -> testGetCardinalityMapNull [label=" iterableA, collectionA, iterableB", dir=none];
union -> testIsSubCollection2 [label=" collectionA", dir=none];
union -> testIsSubCollection [label=" collectionA", dir=none];
union -> intersectionUsesMethodEquals [label=" iterableA, collectionA, collectionC2, iterableB, iterableC", dir=none];
union -> getEnumeration [label=" iterableA, collectionA, iterableB", dir=none];
union -> testIsEqualCollectionReturnsFalse [label=" collectionA", dir=none];
union -> getPositiveOutOfBounds [label=" iterableA, collectionA, iterableB", dir=none];
union -> disjunction [label=" iterableA, collectionA, collectionC2, iterableB, iterableC", dir=none];
union -> isEmpty [label=" collectionA", dir=none];
union -> get1 [label=" iterableA, collectionA, iterableB", dir=none];
union -> testIsSubCollectionOfSelf [label=" collectionA", dir=none];
union -> reverse [label=" collectionA", dir=none];
union -> testHashCode [label=" collectionA", dir=none];
union -> cardinalityOfNull [label=" iterableA, collectionA, iterableB", dir=none];
union -> cardinality [label=" iterableA, iterableB", dir=none];
union -> emptyIfNull [label=" collectionA", dir=none];
union -> testIsEmptyWithNonEmptyCollection [label=" collectionA", dir=none];
union -> filter [label=" iterableA, collectionA, iterableB", dir=none];
union -> testIsEmptyWithEmptyCollection [label=" collectionA", dir=none];
union -> getIterator [label=" iterableA, collectionA, iterableB", dir=none];
union -> getFromObject [label=" iterableA, collectionA, iterableB", dir=none];
union -> addAllForEnumeration [label=" collectionA", dir=none];
union -> testIsEqualCollection [label=" collectionA", dir=none];
union -> getFromList [label=" iterableA, collectionA, iterableB", dir=none];
union -> filterInverse [label=" iterableA, collectionA, iterableB", dir=none];
union -> getFromObjectArray [label=" iterableA, collectionA, iterableB", dir=none];
union -> collect [label=" iterableA, collectionA", dir=none];
union -> testDisjunctionAsUnionMinusIntersection [label=" iterableA, collectionA, collectionC2, iterableB, iterableC", dir=none];
reverse -> forAllButLastDoCollection [label=" collectionA", dir=none];
reverse -> getFromPrimitiveArray [label=" collectionA", dir=none];
reverse -> selectWithOutputCollections [label=" collectionA", dir=none];
reverse -> testPermutations [label=" collectionA", dir=none];
reverse -> testDisjunctionAsSymmetricDifference [label=" collectionA", dir=none];
reverse -> getCardinalityMap [label=" collectionA", dir=none];
reverse -> find [label=" collectionA", dir=none];
reverse -> getFromTreeMap [label=" collectionA", dir=none];
reverse -> intersection [label=" collectionA", dir=none];
reverse -> testGetCardinalityMapNull [label=" collectionA", dir=none];
reverse -> testIsSubCollection2 [label=" collectionA", dir=none];
reverse -> testIsSubCollection [label=" collectionA", dir=none];
reverse -> intersectionUsesMethodEquals [label=" collectionA", dir=none];
reverse -> getEnumeration [label=" collectionA", dir=none];
reverse -> testIsEqualCollectionReturnsFalse [label=" collectionA", dir=none];
reverse -> getPositiveOutOfBounds [label=" collectionA", dir=none];
reverse -> disjunction [label=" collectionA", dir=none];
reverse -> isEmpty [label=" collectionA", dir=none];
reverse -> get1 [label=" collectionA", dir=none];
reverse -> testIsSubCollectionOfSelf [label=" collectionA", dir=none];
reverse -> testHashCode [label=" collectionA", dir=none];
reverse -> cardinalityOfNull [label=" collectionA", dir=none];
reverse -> emptyIfNull [label=" collectionA", dir=none];
reverse -> testIsEmptyWithNonEmptyCollection [label=" collectionA", dir=none];
reverse -> filter [label=" collectionA", dir=none];
reverse -> testIsEmptyWithEmptyCollection [label=" collectionA", dir=none];
reverse -> getIterator [label=" collectionA", dir=none];
reverse -> getFromObject [label=" collectionA", dir=none];
reverse -> addAllForEnumeration [label=" collectionA", dir=none];
reverse -> testIsEqualCollection [label=" collectionA", dir=none];
reverse -> getFromList [label=" collectionA", dir=none];
reverse -> filterInverse [label=" collectionA", dir=none];
reverse -> getFromObjectArray [label=" collectionA", dir=none];
reverse -> collect [label=" collectionA", dir=none];
reverse -> testDisjunctionAsUnionMinusIntersection [label=" collectionA", dir=none];
cardinality -> testDisjunctionAsUnionMinusIntersection [label=" iterableA, iterableB", dir=none];
emptyIfNull -> forAllButLastDoCollection [label=" collectionA", dir=none];
emptyIfNull -> getFromPrimitiveArray [label=" collectionA", dir=none];
emptyIfNull -> selectWithOutputCollections [label=" collectionA", dir=none];
emptyIfNull -> testPermutations [label=" collectionA", dir=none];
emptyIfNull -> testDisjunctionAsSymmetricDifference [label=" collectionA", dir=none];
emptyIfNull -> getCardinalityMap [label=" collectionA", dir=none];
emptyIfNull -> find [label=" collectionA", dir=none];
emptyIfNull -> getFromTreeMap [label=" collectionA", dir=none];
emptyIfNull -> intersection [label=" collectionA", dir=none];
emptyIfNull -> testGetCardinalityMapNull [label=" collectionA", dir=none];
emptyIfNull -> testIsSubCollection2 [label=" collectionA", dir=none];
emptyIfNull -> testIsSubCollection [label=" collectionA", dir=none];
emptyIfNull -> intersectionUsesMethodEquals [label=" collectionA", dir=none];
emptyIfNull -> getEnumeration [label=" collectionA", dir=none];
emptyIfNull -> testIsEqualCollectionReturnsFalse [label=" collectionA", dir=none];
emptyIfNull -> getPositiveOutOfBounds [label=" collectionA", dir=none];
emptyIfNull -> disjunction [label=" collectionA", dir=none];
emptyIfNull -> isEmpty [label=" collectionA", dir=none];
emptyIfNull -> get1 [label=" collectionA", dir=none];
emptyIfNull -> testIsSubCollectionOfSelf [label=" collectionA", dir=none];
emptyIfNull -> testHashCode [label=" collectionA", dir=none];
emptyIfNull -> cardinalityOfNull [label=" collectionA", dir=none];
emptyIfNull -> testIsEmptyWithNonEmptyCollection [label=" collectionA", dir=none];
emptyIfNull -> filter [label=" collectionA", dir=none];
emptyIfNull -> testIsEmptyWithEmptyCollection [label=" collectionA", dir=none];
emptyIfNull -> getIterator [label=" collectionA", dir=none];
emptyIfNull -> getFromObject [label=" collectionA", dir=none];
emptyIfNull -> addAllForEnumeration [label=" collectionA", dir=none];
emptyIfNull -> testIsEqualCollection [label=" collectionA", dir=none];
emptyIfNull -> getFromList [label=" collectionA", dir=none];
emptyIfNull -> filterInverse [label=" collectionA", dir=none];
emptyIfNull -> getFromObjectArray [label=" collectionA", dir=none];
emptyIfNull -> collect [label=" collectionA", dir=none];
emptyIfNull -> testDisjunctionAsUnionMinusIntersection [label=" collectionA", dir=none];
filter -> forAllButLastDoCollection [label=" collectionA", dir=none];
filter -> getFromPrimitiveArray [label=" collectionA, iterableA, iterableB", dir=none];
filter -> selectWithOutputCollections [label=" collectionA, EQUALS_TWO", dir=none];
filter -> testPermutations [label=" collectionA", dir=none];
filter -> testDisjunctionAsSymmetricDifference [label=" collectionA, iterableA, iterableB", dir=none];
filter -> getCardinalityMap [label=" collectionA, iterableA, iterableB", dir=none];
filter -> find [label=" collectionA", dir=none];
filter -> getFromTreeMap [label=" collectionA, iterableA, iterableB", dir=none];
filter -> intersection [label=" collectionA, iterableA, iterableB", dir=none];
filter -> testGetCardinalityMapNull [label=" collectionA, iterableA, iterableB", dir=none];
filter -> testIsSubCollection2 [label=" collectionA", dir=none];
filter -> testIsSubCollection [label=" collectionA", dir=none];
filter -> intersectionUsesMethodEquals [label=" collectionA, iterableA, iterableB", dir=none];
filter -> getEnumeration [label=" collectionA, iterableA, iterableB", dir=none];
filter -> testIsEqualCollectionReturnsFalse [label=" collectionA", dir=none];
filter -> getPositiveOutOfBounds [label=" collectionA, iterableA, iterableB", dir=none];
filter -> disjunction [label=" collectionA, iterableA, iterableB", dir=none];
filter -> selectRejected [label=" EQUALS_TWO", dir=none];
filter -> isEmpty [label=" collectionA", dir=none];
filter -> get1 [label=" collectionA, iterableA, iterableB", dir=none];
filter -> testIsSubCollectionOfSelf [label=" collectionA", dir=none];
filter -> testHashCode [label=" collectionA", dir=none];
filter -> cardinalityOfNull [label=" collectionA, iterableA, iterableB", dir=none];
filter -> cardinality [label=" iterableA, iterableB", dir=none];
filter -> testIsEmptyWithNonEmptyCollection [label=" collectionA", dir=none];
filter -> testIsEmptyWithEmptyCollection [label=" collectionA", dir=none];
filter -> getIterator [label=" collectionA, iterableA, iterableB", dir=none];
filter -> getFromObject [label=" collectionA, iterableA, iterableB", dir=none];
filter -> addAllForEnumeration [label=" collectionA", dir=none];
filter -> testIsEqualCollection [label=" collectionA", dir=none];
filter -> getFromList [label=" collectionA, iterableA, iterableB", dir=none];
filter -> exists [label=" EQUALS_TWO", dir=none];
filter -> filterInverse [label=" collectionA, iterableA, EQUALS_TWO, iterableB", dir=none];
filter -> getFromObjectArray [label=" collectionA, iterableA, iterableB", dir=none];
filter -> collect [label=" collectionA, iterableA", dir=none];
filter -> testDisjunctionAsUnionMinusIntersection [label=" collectionA, iterableA, iterableB", dir=none];
testIsEmptyWithEmptyCollection -> forAllButLastDoCollection [label=" collectionA", dir=none];
testIsEmptyWithEmptyCollection -> getFromPrimitiveArray [label=" collectionA", dir=none];
testIsEmptyWithEmptyCollection -> selectWithOutputCollections [label=" collectionA", dir=none];
testIsEmptyWithEmptyCollection -> testPermutations [label=" collectionA", dir=none];
testIsEmptyWithEmptyCollection -> testDisjunctionAsSymmetricDifference [label=" collectionA", dir=none];
testIsEmptyWithEmptyCollection -> getCardinalityMap [label=" collectionA", dir=none];
testIsEmptyWithEmptyCollection -> find [label=" collectionA", dir=none];
testIsEmptyWithEmptyCollection -> getFromTreeMap [label=" collectionA", dir=none];
testIsEmptyWithEmptyCollection -> intersection [label=" collectionA", dir=none];
testIsEmptyWithEmptyCollection -> testGetCardinalityMapNull [label=" collectionA", dir=none];
testIsEmptyWithEmptyCollection -> testIsSubCollection2 [label=" collectionA", dir=none];
testIsEmptyWithEmptyCollection -> testIsSubCollection [label=" collectionA", dir=none];
testIsEmptyWithEmptyCollection -> intersectionUsesMethodEquals [label=" collectionA", dir=none];
testIsEmptyWithEmptyCollection -> getEnumeration [label=" collectionA", dir=none];
testIsEmptyWithEmptyCollection -> testIsEqualCollectionReturnsFalse [label=" collectionA", dir=none];
testIsEmptyWithEmptyCollection -> getPositiveOutOfBounds [label=" collectionA", dir=none];
testIsEmptyWithEmptyCollection -> disjunction [label=" collectionA", dir=none];
testIsEmptyWithEmptyCollection -> isEmpty [label=" collectionA", dir=none];
testIsEmptyWithEmptyCollection -> get1 [label=" collectionA", dir=none];
testIsEmptyWithEmptyCollection -> testIsSubCollectionOfSelf [label=" collectionA", dir=none];
testIsEmptyWithEmptyCollection -> testHashCode [label=" collectionA", dir=none];
testIsEmptyWithEmptyCollection -> cardinalityOfNull [label=" collectionA", dir=none];
testIsEmptyWithEmptyCollection -> testIsEmptyWithNonEmptyCollection [label=" collectionA", dir=none];
testIsEmptyWithEmptyCollection -> getIterator [label=" collectionA", dir=none];
testIsEmptyWithEmptyCollection -> getFromObject [label=" collectionA", dir=none];
testIsEmptyWithEmptyCollection -> addAllForEnumeration [label=" collectionA", dir=none];
testIsEmptyWithEmptyCollection -> testIsEqualCollection [label=" collectionA", dir=none];
testIsEmptyWithEmptyCollection -> getFromList [label=" collectionA", dir=none];
testIsEmptyWithEmptyCollection -> filterInverse [label=" collectionA", dir=none];
testIsEmptyWithEmptyCollection -> getFromObjectArray [label=" collectionA", dir=none];
testIsEmptyWithEmptyCollection -> collect [label=" collectionA", dir=none];
testIsEmptyWithEmptyCollection -> testDisjunctionAsUnionMinusIntersection [label=" collectionA", dir=none];
getFromObject -> forAllButLastDoCollection [label=" collectionA", dir=none];
getFromObject -> getFromPrimitiveArray [label=" collectionA, iterableA, iterableB", dir=none];
getFromObject -> selectWithOutputCollections [label=" collectionA", dir=none];
getFromObject -> testPermutations [label=" collectionA", dir=none];
getFromObject -> testDisjunctionAsSymmetricDifference [label=" collectionA, iterableA, iterableB", dir=none];
getFromObject -> getCardinalityMap [label=" collectionA, iterableA, iterableB", dir=none];
getFromObject -> find [label=" collectionA", dir=none];
getFromObject -> getFromTreeMap [label=" collectionA, iterableA, iterableB", dir=none];
getFromObject -> intersection [label=" collectionA, iterableA, iterableB", dir=none];
getFromObject -> testGetCardinalityMapNull [label=" collectionA, iterableA, iterableB", dir=none];
getFromObject -> testIsSubCollection2 [label=" collectionA", dir=none];
getFromObject -> testIsSubCollection [label=" collectionA", dir=none];
getFromObject -> intersectionUsesMethodEquals [label=" collectionA, iterableA, iterableB", dir=none];
getFromObject -> getEnumeration [label=" collectionA, iterableA, iterableB", dir=none];
getFromObject -> testIsEqualCollectionReturnsFalse [label=" collectionA", dir=none];
getFromObject -> getPositiveOutOfBounds [label=" collectionA, iterableA, iterableB", dir=none];
getFromObject -> disjunction [label=" collectionA, iterableA, iterableB", dir=none];
getFromObject -> isEmpty [label=" collectionA", dir=none];
getFromObject -> get1 [label=" collectionA, iterableA, iterableB", dir=none];
getFromObject -> testIsSubCollectionOfSelf [label=" collectionA", dir=none];
getFromObject -> testHashCode [label=" collectionA", dir=none];
getFromObject -> cardinalityOfNull [label=" collectionA, iterableA, iterableB", dir=none];
getFromObject -> cardinality [label=" iterableA, iterableB", dir=none];
getFromObject -> testIsEmptyWithNonEmptyCollection [label=" collectionA", dir=none];
getFromObject -> getIterator [label=" collectionA, iterableA, iterableB", dir=none];
getFromObject -> addAllForEnumeration [label=" collectionA", dir=none];
getFromObject -> testIsEqualCollection [label=" collectionA", dir=none];
getFromObject -> getFromList [label=" collectionA, iterableA, iterableB", dir=none];
getFromObject -> filterInverse [label=" collectionA, iterableA, iterableB", dir=none];
getFromObject -> getFromObjectArray [label=" collectionA, iterableA, iterableB", dir=none];
getFromObject -> collect [label=" collectionA, iterableA", dir=none];
getFromObject -> testDisjunctionAsUnionMinusIntersection [label=" collectionA, iterableA, iterableB", dir=none];
addAllForEnumeration -> testDisjunctionAsUnionMinusIntersection [label=" collectionA", dir=none];
testIsEqualCollection -> forAllButLastDoCollection [label=" collectionA", dir=none];
testIsEqualCollection -> getFromPrimitiveArray [label=" collectionA", dir=none];
testIsEqualCollection -> selectWithOutputCollections [label=" collectionA", dir=none];
testIsEqualCollection -> testPermutations [label=" collectionA", dir=none];
testIsEqualCollection -> testDisjunctionAsSymmetricDifference [label=" collectionA, collectionC", dir=none];
testIsEqualCollection -> getCardinalityMap [label=" collectionA", dir=none];
testIsEqualCollection -> find [label=" collectionA", dir=none];
testIsEqualCollection -> getFromTreeMap [label=" collectionA", dir=none];
testIsEqualCollection -> intersection [label=" collectionA", dir=none];
testIsEqualCollection -> testGetCardinalityMapNull [label=" collectionA", dir=none];
testIsEqualCollection -> testIsSubCollection2 [label=" collectionA", dir=none];
testIsEqualCollection -> testIsSubCollection [label=" collectionA, collectionC", dir=none];
testIsEqualCollection -> intersectionUsesMethodEquals [label=" collectionA", dir=none];
testIsEqualCollection -> getEnumeration [label=" collectionA", dir=none];
testIsEqualCollection -> testIsEqualCollectionReturnsFalse [label=" collectionA", dir=none];
testIsEqualCollection -> getPositiveOutOfBounds [label=" collectionA", dir=none];
testIsEqualCollection -> disjunction [label=" collectionA", dir=none];
testIsEqualCollection -> isEmpty [label=" collectionA", dir=none];
testIsEqualCollection -> get1 [label=" collectionA", dir=none];
testIsEqualCollection -> testIsSubCollectionOfSelf [label=" collectionA", dir=none];
testIsEqualCollection -> testHashCode [label=" collectionA", dir=none];
testIsEqualCollection -> cardinalityOfNull [label=" collectionA", dir=none];
testIsEqualCollection -> testIsEmptyWithNonEmptyCollection [label=" collectionA", dir=none];
testIsEqualCollection -> getIterator [label=" collectionA", dir=none];
testIsEqualCollection -> addAllForEnumeration [label=" collectionA", dir=none];
testIsEqualCollection -> getFromList [label=" collectionA", dir=none];
testIsEqualCollection -> filterInverse [label=" collectionA", dir=none];
testIsEqualCollection -> getFromObjectArray [label=" collectionA", dir=none];
testIsEqualCollection -> collect [label=" collectionA", dir=none];
testIsEqualCollection -> testDisjunctionAsUnionMinusIntersection [label=" collectionA, collectionC", dir=none];
getFromList -> forAllButLastDoCollection [label=" collectionA", dir=none];
getFromList -> getFromPrimitiveArray [label=" collectionA, iterableA, iterableB", dir=none];
getFromList -> selectWithOutputCollections [label=" collectionA", dir=none];
getFromList -> testPermutations [label=" collectionA", dir=none];
getFromList -> testDisjunctionAsSymmetricDifference [label=" collectionA, iterableA, iterableB", dir=none];
getFromList -> getCardinalityMap [label=" collectionA, iterableA, iterableB", dir=none];
getFromList -> find [label=" collectionA", dir=none];
getFromList -> getFromTreeMap [label=" collectionA, iterableA, iterableB", dir=none];
getFromList -> intersection [label=" collectionA, iterableA, iterableB", dir=none];
getFromList -> testGetCardinalityMapNull [label=" collectionA, iterableA, iterableB", dir=none];
getFromList -> testIsSubCollection2 [label=" collectionA", dir=none];
getFromList -> testIsSubCollection [label=" collectionA", dir=none];
getFromList -> intersectionUsesMethodEquals [label=" collectionA, iterableA, iterableB", dir=none];
getFromList -> getEnumeration [label=" collectionA, iterableA, iterableB", dir=none];
getFromList -> testIsEqualCollectionReturnsFalse [label=" collectionA", dir=none];
getFromList -> getPositiveOutOfBounds [label=" collectionA, iterableA, iterableB", dir=none];
getFromList -> disjunction [label=" collectionA, iterableA, iterableB", dir=none];
getFromList -> isEmpty [label=" collectionA", dir=none];
getFromList -> get1 [label=" collectionA, iterableA, iterableB", dir=none];
getFromList -> testIsSubCollectionOfSelf [label=" collectionA", dir=none];
getFromList -> testHashCode [label=" collectionA", dir=none];
getFromList -> cardinalityOfNull [label=" collectionA, iterableA, iterableB", dir=none];
getFromList -> cardinality [label=" iterableA, iterableB", dir=none];
getFromList -> testIsEmptyWithNonEmptyCollection [label=" collectionA", dir=none];
getFromList -> getIterator [label=" collectionA, iterableA, iterableB", dir=none];
getFromList -> addAllForEnumeration [label=" collectionA", dir=none];
getFromList -> filterInverse [label=" collectionA, iterableA, iterableB", dir=none];
getFromList -> getFromObjectArray [label=" collectionA, iterableA, iterableB", dir=none];
getFromList -> collect [label=" collectionA, iterableA", dir=none];
getFromList -> testDisjunctionAsUnionMinusIntersection [label=" collectionA, iterableA, iterableB", dir=none];
exists -> selectWithOutputCollections [label=" EQUALS_TWO", dir=none];
exists -> selectRejected [label=" EQUALS_TWO", dir=none];
exists -> filterInverse [label=" EQUALS_TWO", dir=none];
}